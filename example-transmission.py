from datetime import time
import os
from quantumstring.field import OneSpaceField

from quantumstring.simulation import CenterFixed, FreeString, RingString, Simulation, Cavity
from quantumstring.edge import ExcitatorSinAbsorber, MirrorEdge, ExcitatorSin, AbsorberEdge
from quantumstring.particle import Particles, Particle
from quantumstring.process import PostProcess

import numpy as np
from matplotlib import pyplot as plt
from scipy import fftpack as fft

mypath = os.path.dirname(os.path.abspath(__file__))
mypath = "C:\\Users\\leog\\Desktop\\lg2021stage\\output"

duration = 2.0 # [s]
space_steps = 1023
length = 6.0 # [m]
tension = 5.0 # [N]
density = 0.005 # [kg/m]

c = np.sqrt(tension/density)
dx = length/space_steps
dt = dx/c
time_steps = int(duration/dt)
duration = dt*time_steps

frequencies = np.array([i for i in range(20, 100, 5)]).astype(float) # excitator frequencies we use for the simulations
pulsations = 2*np.pi*frequencies

# caracteristics for the mass
pmass = 0.001 # [kg]
pstiff = 250.0 # [N/m]
pomega = np.sqrt(pstiff/pmass) # [rad/s]

t_theory_list = []
t_exp_list = []

transmission_value = lambda a: 1/(1 - np.complex(0, 1)/a) # theoretical expression of 't' as a function of α

for omega in pulsations:
    # we create the edges
    examp = 0.05 # [m]
    right = AbsorberEdge()
    left = ExcitatorSinAbsorber(dt, examp, omega)
    k = omega/c
    excitator = lambda x, t: examp*np.sin(k*x - omega*t) # we define the field generated by the excitator, as a function of x and t

    # initial fields (at rest)
    ic0 = [0.0]*space_steps
    ic1 = [0.0]*space_steps

    p = Particle(int(space_steps*0.5), 0.0, pmass, pstiff, True, space_steps) # we create the particle
    ps = Particles(p, space_steps=space_steps) # and put it in the particles class
    simu = Simulation(dt, time_steps, space_steps, length, density, tension, left, right, ic0, ic1, ps, log=True) # we create the simulation
    simu.run(mypath, file=False) # ... and run it

    last_ts = simu.s.field.current_time_step()
    last_field = simu.s.field.get_val_time(last_ts) # here we get the field at the very last time of simulation
    last_time = last_ts*dt
    xlin = np.linspace(0.0, length, space_steps)
    field_from_excitator = excitator(xlin, last_time) # ... and generate what the field would be without the particle

    # from these two fields, we extract only the last part, after the particle
    win_end_a, win_end_b = int(0.53*space_steps), space_steps - 1
    right_field_sim = last_field[win_end_a:win_end_b]
    amp_sim = max(right_field_sim)
    right_field_ex = field_from_excitator[win_end_a:win_end_b]
    amp_ex = max(right_field_ex)

    ### MODULE: 
    ### to compute it, we simply find the max value of the field, it will be equal to the amplitude.
    ### then divide it by the excitator amplitude and we get the modulus of t
    after = last_field[int(space_steps*0.55):int(space_steps*0.95)]
    max_after = max(after)
    mod_t = max_after/examp

    ### PHASE:
    ### field after particle (at t=T): u(x) = A cos(kx - ωT)
    ### field WITHOUT PARTICLE after particle, (at t=T): v(x) = A cos(kx - ωT + φ)
    ### then: φ = acos(u(x)/A) - acos(v(x)/A)
    phase_list = np.arccos(right_field_ex/amp_ex) - np.arccos(right_field_sim/amp_sim)
    max_phase = max(phase_list)
    phase_list = phase_list[max_phase*0.5 < phase_list] # will remove the undesired 'nan' and osef values
    phase_t = np.mean(phase_list)


    ### THEORY:
    alpha = 2*omega*density*c/(pstiff - pmass*omega**2)
    t_theory = transmission_value(alpha)
    t_exp = mod_t*(np.cos(phase_t) + np.sin(phase_t)*1j)

    t_exp = t_exp.conjugate() if np.angle(t_theory) < 0 else t_exp # we try to heal the ± problem...

    t_theory_list.append(t_theory)
    t_exp_list.append(t_exp)

    print("ω={}Hz (/{})".format(omega, pulsations[-1]))
    print("|t|\n    ={} (theory)\n    ={} (simulation)".format(np.abs(t_theory), np.abs(t_exp)))
    print("arg(t)\n    ={} (theory)\n    ={} (simulation)".format(np.angle(t_theory), np.angle(t_exp)))

pulsation_spectrum = np.linspace(1.0, 1000.0, 2000)
alpha_spectrum = 2*density*c*pulsation_spectrum/(pstiff - pmass*pulsation_spectrum**2)
t_spectrum = transmission_value(alpha_spectrum)
mod_sqr_spectrum = t_spectrum*t_spectrum.conjugate()
angle_spectrum = np.angle(t_spectrum) 

nb_pts = len(t_theory_list)
cmap = plt.cm.get_cmap("plasma", nb_pts)

### PLOT DESIGN:
### we make the layout for the graphs
fig = plt.figure(constrained_layout=True)
gs = fig.add_gridspec(2, 2)
ax_cplx = fig.add_subplot(gs[:, 0])
ax_mod = fig.add_subplot(gs[0, 1])
ax_angle = fig.add_subplot(gs[1, 1])

ax_cplx.set_xlim((-0.05, 1.05))
ax_cplx.set_ylim((-0.55, 0.55))
ax_cplx.set_title("Complex transmission coefficient $t$, function of excitator frequency")
ax_cplx.set_xlabel("$Re \; t$")
ax_cplx.set_ylabel("$Im \; t$")
ax_cplx.grid()

ax_mod.set_title("$|t|²$")
ax_mod.set_xlabel("$\omega / \omega_0$")
ax_mod.set_ylabel("$|t|²$")
ax_mod.grid()

ax_angle.set_title("$arg(t)$")
ax_angle.set_xlabel("$\omega / \omega_0 $")
ax_angle.set_ylabel("$arg(t)$")
ax_angle.grid()

# we plot the theoretical values
ax_cplx.plot(t_spectrum.real, t_spectrum.imag, "k-")
ax_mod.plot(pulsation_spectrum/pomega, mod_sqr_spectrum, "k-")
ax_angle.plot(pulsation_spectrum/pomega, angle_spectrum, "k-")

for the, exp, count, omega in zip(t_theory_list, t_exp_list, range(0, nb_pts), pulsations):
    c = cmap(count)
    label = label="{:.0f}Hz".format(omega*0.5/np.pi)

    ax_cplx.plot([0.0, exp.real], [0.0, exp.imag], linestyle="solid", color=c, label=label)
    ax_cplx.legend()
    ax_cplx.plot([exp.real, the.real], [exp.imag, the.imag], linestyle="dotted", linewidth=0.5, color=c)
    ax_cplx.plot(the.real, the.imag, ".", linewidth=0.5, color=c)

    ax_mod.plot(omega/pomega, np.abs(exp)**2, "x", color=c)
    ax_mod.plot(omega/pomega, np.abs(the)**2, ".", color=c, linewidth=1)

    ax_angle.plot(omega/pomega, np.angle(exp), "x", color=c)
    ax_angle.plot(omega/pomega, np.angle(the), ".", color=c, linewidth=1)

plt.show()