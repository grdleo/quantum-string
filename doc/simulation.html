<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>quantumstring.simulation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quantumstring.simulation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
import os
import math
import datetime
import json

from quantumstring.phystring import PhyString
from quantumstring.particle import Particle, Particles
from quantumstring.edge import Edge, MirrorEdge, LoopEdge

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw
import cv2
import ffmpeg

&#34;&#34;&#34;
    Classes for making simulations of the system
&#34;&#34;&#34;

class Simulation:
    &#34;&#34;&#34;
        Class that wraps the whole simulation thing
    &#34;&#34;&#34;
    IMG_PREFIX = &#34;qs_img___&#34;
    VID_PREFIX = &#34;QuantumString&#34;
    IMG_FORMAT = &#34;png&#34;
    PERCENT_MAX = 256

    STR_DT = &#34;dt&#34;
    STR_DX = &#34;dx&#34;
    STR_TIMESTEPS = &#34;nt&#34;
    STR_SPACESTEPS = &#34;nx&#34;
    STR_TENSION = &#34;T&#34;
    STR_DENSITY = &#34;rho&#34;
    STR_LENGTH = &#34;L&#34;
    STR_EDGE_LEFT = &#34;edge_left&#34;
    STR_EDGE_RIGHT = &#34;edge_right&#34;

    BLACK = (0, 0, 0)
    RED = (255, 0, 0)
    GREEN = (0, 255, 0)
    BLUE = (0, 0, 255)
    GRAY = (64, 64, 64)
    WHITE = (255, 255, 255)

    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, ic0: list[float], ic1: list[float], particles, memory_field=5, log=True):
        &#34;&#34;&#34;
            Initialisation of the simulation

            :param dt: value of the time step [s]
            :param time_steps: number of time steps
            :param space_steps: number of cells in the string
            :param string_len: length of the string [m]
            :param string_c: celerity of the string [m/s]
            :param string_density: linear density of the string [kg/m]
            :param edge_left: the condition at the left extremity of the string
            :param edge_right: the condition at the right extremity of the string
            :param ic_pos: initial condition of the position of the string
            :param ic_vel: initial condition of the velocity of the string
            :param particles: Particles object
            :param memory_field:
            :param log: if True, prints the simulation loading
        &#34;&#34;&#34;
        self.log = log
        self.time_steps = time_steps
        self.dt = dt
        self.time = str(datetime.datetime.now())

        self.s = PhyString(string_len, space_steps, dt, string_density, string_tension, edge_left, edge_right, ic0, ic1, particles, memory_field=memory_field)
    
    def infos(self) -&gt; dict[str]:
        &#34;&#34;&#34;
            Returns a dictionary containing the informations about the simulation
        &#34;&#34;&#34;
        return {
            &#34;desc&#34;: &#34;QUANTUM STRING SIMULATION&#34;,
            &#34;date&#34;: self.time,
            Simulation.STR_DT: self.s.dt,
            Simulation.STR_DX: self.s.dx,
            Simulation.STR_TIMESTEPS: self.time_steps,
            Simulation.STR_SPACESTEPS: self.s.space_steps,
            Simulation.STR_LENGTH: self.s.length,
            Simulation.STR_TENSION: self.s.tension,
            Simulation.STR_DENSITY: self.s.linear_density,
            Simulation.STR_EDGE_LEFT: str(self.s.edge_left),
            Simulation.STR_EDGE_RIGHT: str(self.s.edge_right),
            &#34;particles&#34;: self.s.particles.infos()
        }
    
    def __repr__(self):
        return &#34;[SIMULATION]    Δt={}s, Δx={}m, time steps={}, space steps={}\n{}\n{}\nEstimation of simulation size = {}MB&#34;.format(
            self.s.dt, 
            self.s.dx, 
            self.time_steps, 
            self.s.space_steps,
            self.s,
            self.s.particles,
            int(self.size_estimation_mb()))

    def run(self, path: str, file=True) -&gt; tuple[str, str]:
        &#34;&#34;&#34;
            Runs the simulation with options to save it as a animation and/or in a file
            Returns the path of the field, particles and energy file generated

            :param path: location where to save the outputs
            :param file: if `True`, saves the simulation to files
        &#34;&#34;&#34;
        dtnow = datetime.datetime.now()
        timestamp = int(dtnow.timestamp())
        jsoninfos = json.dumps(self.infos())
        print(self) if self.log else None

        field_file_path = os.path.join(path, &#34;QuantumString-field_{}.txt&#34;.format(timestamp))
        particles_file_path = os.path.join(path, &#34;QuantumString-particles_{}.txt&#34;.format(timestamp))
        energy_field_path = os.path.join(path, &#34;QuantumString-energy_{}.txt&#34;.format(timestamp))

        begtxt = &#34;{}\n&#34;.format(jsoninfos)

        if file:
            ff = open(field_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)
            pf = open(particles_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)
            ef = open(energy_field_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)

            ff.write(begtxt)
            pf.write(begtxt)
            ef.write(begtxt)

        ts = datetime.datetime.now()
        percent = 0
        list_dt_compute = []
        for t in range(0, self.time_steps):
            if t &gt; 1: # do not update when the timesteps are lower than 1 bc this corresponds to the two initial fields
                self.s.update() # update the string
            
            # printing the update to the console...
            prop = t/self.time_steps
            newpercent = math.floor(prop*Simulation.PERCENT_MAX)
            if (newpercent != percent) and self.log: # update the console
                newts = datetime.datetime.now()
                dtcompute = (newts - ts).total_seconds()
                elapsed = sum(list_dt_compute)
                list_dt_compute.append(dtcompute)
                spinner = &#34;⡀⡁⡂⡃⡄⡅⡆⡇⡈⡉⡊⡋⡌⡍⡎⡏⡐⡑⡒⡓⡔⡕⡖⡗⡘⡙⡚⡛⡜⡝⡞⡟⡠⡡⡢⡣⡤⡥⡦⡧⡨⡩⡪⡫⡬⡭⡮⡯⡰⡱⡲⡳⡴⡵⡶⡷⡸⡹⡺⡻⡼⡽⡾⡿⢀⢁⢂⢃⢄⢅⢆⢇⢈⢉⢊⢋⢌⢍⢎⢏⢐⢑⢒⢓⢔⢕⢖⢗⢘⢙⢚⢛⢜⢝⢞⢟⢠⢡⢢⢣⢤⢥⢦⢧⢨⢩⢪⢫⢬⢭⢮⢯⢰⢱⢲⢳⢴⢵⢶⢷⢸⢹⢺⢻⢼⢽⢾⢿⣀⣁⣂⣃⣄⣅⣆⣇⣈⣉⣊⣋⣌⣍⣎⣏⣐⣑⣒⣓⣔⣕⣖⣗⣘⣙⣚⣛⣜⣝⣞⣟⣠⣡⣢⣣⣤⣥⣦⣧⣨⣩⣪⣫⣬⣭⣮⣯⣰⣱⣲⣳⣴⣵⣶⣷⣸⣹⣺⣻⣼⣽⣾⣿&#34;
                load = percent % len(spinner)
                print(&#34;{:2}% {} {:.4f}s left                &#34;.format(int(percent/Simulation.PERCENT_MAX*100), spinner[load:load+1],  float(elapsed*(1/prop-1))), end=&#34;\r&#34;)
                ts = newts
            percent = newpercent
            # ...
            
            # writing the fields in the files
            f = self.s.field.get_val_time(t)
            pp = self.s.particles.list_pos(tstep=t)
            e = self.s.energy.get_val_time(t)
            
            if file:
                fstr = Simulation.list2str(f)
                pstr = Simulation.list2str(pp)
                estr = Simulation.list2str(e)

                ff.write(&#34;{}\n&#34;.format(fstr))
                pf.write(&#34;{}\n&#34;.format(pstr))
                ef.write(&#34;{}\n&#34;.format(estr))
        print(&#34;&#34;)

        if file:
            ff.close()
            pf.close()
            ef.close()

        return field_file_path, particles_file_path, energy_field_path
    
    def size_estimation_mb(self) -&gt; float:
        &#34;&#34;&#34;
            Gives an estimation of the final size of the field file, in MB (Mo in french)
        &#34;&#34;&#34;
        bytes_per_cell = 21
        return bytes_per_cell*self.s.space_steps*self.time_steps*1e-6

    @staticmethod
    def list2str(l: list) -&gt; str:
        &#34;&#34;&#34;
            Converts a list to a string in a simple format for our use

            ```
            &gt;&gt;&gt; list2str([1, 2, 3])
            &#39;1,2,3&#39;
            ```
        &#34;&#34;&#34;
        return str(list(l)).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34; &#34;, &#34;&#34;).replace(&#34;\n&#34;, &#34;&#34;)
    
    @staticmethod
    def str2list(s: str, type=float) -&gt; list:
        &#34;&#34;&#34;
            Converts a converted string back into a NumPy array. The type of values can be specified

            ```
            &gt;&gt;&gt; str2list(&#34;1,2,3&#34;)
            [1, 2, 3]
            ```
        &#34;&#34;&#34;
        s = s.replace(&#34;\n&#34;, &#34;&#34;)
        l = s.split(&#34;,&#34;)
        return np.array(l).astype(type) if s != &#34;&#34; else np.array([])

#################################################################

class RestString(Simulation):
    &#34;&#34;&#34;
        Abstraction of Simulation: the initial field is at rest
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, particles, log=True, memory_field=5):
        ic0 = [0.0]*space_steps
        ic1 = ic0.copy()
        super().__init__(dt, time_steps,  space_steps, string_len, string_density, string_tension, edge_left, edge_right, ic0, ic1, particles, log=log, memory_field=memory_field)

class FreeString(RestString):
    &#34;&#34;&#34;
        Abstraction of RestString: the system is particle free
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, log=True, memory_field=5):
        particles = Particles(space_steps=space_steps)
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, edge_left, edge_right, particles, log=log, memory_field=memory_field)

class CenterFixed(RestString):
    &#34;&#34;&#34;
        Abstraction of RestString: the system has a single particle in the center of the string
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, mass_particle: float, pulsation_particle: float, log=True, memory_field=5):
        center_string = math.floor(space_steps*0.5)
        stiffness = mass_particle*pulsation_particle**2
        p = Particle(center_string, 0.0, mass_particle, stiffness, True, space_steps)
        particles = Particles(p)
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, edge_left, edge_right, particles, log=log, memory_field=memory_field)

class Cavity(Simulation):
    &#34;&#34;&#34;
        Abstraction of Simulation: mirrors in both ends, initial position given but initial velocity is zero
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, ic0: list[float], ic1: list[float], particles: Particles, log=True, memory_field=5):
        ml, mr = MirrorEdge(), MirrorEdge()
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, ml, mr, ic0, ic1, particles, log=log, memory_field=memory_field)

class RingString(Simulation):
    &#34;&#34;&#34;
        Abstraction of Simulation: both ends are connected (equivalent of a ring)
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, ic0: list[float], ic1: list[float], particles: Particles, log=True, memory_field=5):
        ll, lr = LoopEdge(), LoopEdge()
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, ll, lr, ic0, ic1, particles, log=log, memory_field=memory_field)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="quantumstring.simulation.Cavity"><code class="flex name class">
<span>class <span class="ident">Cavity</span></span>
<span>(</span><span>dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, ic0: list[float], ic1: list[float], particles: Particles, log=True, memory_field=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of Simulation: mirrors in both ends, initial position given but initial velocity is zero</p>
<p>Initialisation of the simulation</p>
<p>:param dt: value of the time step [s]
:param time_steps: number of time steps
:param space_steps: number of cells in the string
:param string_len: length of the string [m]
:param string_c: celerity of the string [m/s]
:param string_density: linear density of the string [kg/m]
:param edge_left: the condition at the left extremity of the string
:param edge_right: the condition at the right extremity of the string
:param ic_pos: initial condition of the position of the string
:param ic_vel: initial condition of the velocity of the string
:param particles: Particles object
:param memory_field:
:param log: if True, prints the simulation loading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cavity(Simulation):
    &#34;&#34;&#34;
        Abstraction of Simulation: mirrors in both ends, initial position given but initial velocity is zero
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, ic0: list[float], ic1: list[float], particles: Particles, log=True, memory_field=5):
        ml, mr = MirrorEdge(), MirrorEdge()
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, ml, mr, ic0, ic1, particles, log=log, memory_field=memory_field)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></b></code>:
<ul class="hlist">
<li><code><a title="quantumstring.simulation.Simulation.infos" href="#quantumstring.simulation.Simulation.infos">infos</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.list2str" href="#quantumstring.simulation.Simulation.list2str">list2str</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.run" href="#quantumstring.simulation.Simulation.run">run</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.size_estimation_mb" href="#quantumstring.simulation.Simulation.size_estimation_mb">size_estimation_mb</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.str2list" href="#quantumstring.simulation.Simulation.str2list">str2list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quantumstring.simulation.CenterFixed"><code class="flex name class">
<span>class <span class="ident">CenterFixed</span></span>
<span>(</span><span>dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, mass_particle: float, pulsation_particle: float, log=True, memory_field=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of RestString: the system has a single particle in the center of the string</p>
<p>Initialisation of the simulation</p>
<p>:param dt: value of the time step [s]
:param time_steps: number of time steps
:param space_steps: number of cells in the string
:param string_len: length of the string [m]
:param string_c: celerity of the string [m/s]
:param string_density: linear density of the string [kg/m]
:param edge_left: the condition at the left extremity of the string
:param edge_right: the condition at the right extremity of the string
:param ic_pos: initial condition of the position of the string
:param ic_vel: initial condition of the velocity of the string
:param particles: Particles object
:param memory_field:
:param log: if True, prints the simulation loading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CenterFixed(RestString):
    &#34;&#34;&#34;
        Abstraction of RestString: the system has a single particle in the center of the string
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, mass_particle: float, pulsation_particle: float, log=True, memory_field=5):
        center_string = math.floor(space_steps*0.5)
        stiffness = mass_particle*pulsation_particle**2
        p = Particle(center_string, 0.0, mass_particle, stiffness, True, space_steps)
        particles = Particles(p)
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, edge_left, edge_right, particles, log=log, memory_field=memory_field)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quantumstring.simulation.RestString" href="#quantumstring.simulation.RestString">RestString</a></li>
<li><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quantumstring.simulation.RestString" href="#quantumstring.simulation.RestString">RestString</a></b></code>:
<ul class="hlist">
<li><code><a title="quantumstring.simulation.RestString.infos" href="#quantumstring.simulation.Simulation.infos">infos</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.list2str" href="#quantumstring.simulation.Simulation.list2str">list2str</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.run" href="#quantumstring.simulation.Simulation.run">run</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.size_estimation_mb" href="#quantumstring.simulation.Simulation.size_estimation_mb">size_estimation_mb</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.str2list" href="#quantumstring.simulation.Simulation.str2list">str2list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quantumstring.simulation.FreeString"><code class="flex name class">
<span>class <span class="ident">FreeString</span></span>
<span>(</span><span>dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, log=True, memory_field=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of RestString: the system is particle free</p>
<p>Initialisation of the simulation</p>
<p>:param dt: value of the time step [s]
:param time_steps: number of time steps
:param space_steps: number of cells in the string
:param string_len: length of the string [m]
:param string_c: celerity of the string [m/s]
:param string_density: linear density of the string [kg/m]
:param edge_left: the condition at the left extremity of the string
:param edge_right: the condition at the right extremity of the string
:param ic_pos: initial condition of the position of the string
:param ic_vel: initial condition of the velocity of the string
:param particles: Particles object
:param memory_field:
:param log: if True, prints the simulation loading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FreeString(RestString):
    &#34;&#34;&#34;
        Abstraction of RestString: the system is particle free
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, log=True, memory_field=5):
        particles = Particles(space_steps=space_steps)
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, edge_left, edge_right, particles, log=log, memory_field=memory_field)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quantumstring.simulation.RestString" href="#quantumstring.simulation.RestString">RestString</a></li>
<li><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quantumstring.simulation.RestString" href="#quantumstring.simulation.RestString">RestString</a></b></code>:
<ul class="hlist">
<li><code><a title="quantumstring.simulation.RestString.infos" href="#quantumstring.simulation.Simulation.infos">infos</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.list2str" href="#quantumstring.simulation.Simulation.list2str">list2str</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.run" href="#quantumstring.simulation.Simulation.run">run</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.size_estimation_mb" href="#quantumstring.simulation.Simulation.size_estimation_mb">size_estimation_mb</a></code></li>
<li><code><a title="quantumstring.simulation.RestString.str2list" href="#quantumstring.simulation.Simulation.str2list">str2list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quantumstring.simulation.RestString"><code class="flex name class">
<span>class <span class="ident">RestString</span></span>
<span>(</span><span>dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, particles, log=True, memory_field=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of Simulation: the initial field is at rest</p>
<p>Initialisation of the simulation</p>
<p>:param dt: value of the time step [s]
:param time_steps: number of time steps
:param space_steps: number of cells in the string
:param string_len: length of the string [m]
:param string_c: celerity of the string [m/s]
:param string_density: linear density of the string [kg/m]
:param edge_left: the condition at the left extremity of the string
:param edge_right: the condition at the right extremity of the string
:param ic_pos: initial condition of the position of the string
:param ic_vel: initial condition of the velocity of the string
:param particles: Particles object
:param memory_field:
:param log: if True, prints the simulation loading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestString(Simulation):
    &#34;&#34;&#34;
        Abstraction of Simulation: the initial field is at rest
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, particles, log=True, memory_field=5):
        ic0 = [0.0]*space_steps
        ic1 = ic0.copy()
        super().__init__(dt, time_steps,  space_steps, string_len, string_density, string_tension, edge_left, edge_right, ic0, ic1, particles, log=log, memory_field=memory_field)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="quantumstring.simulation.CenterFixed" href="#quantumstring.simulation.CenterFixed">CenterFixed</a></li>
<li><a title="quantumstring.simulation.FreeString" href="#quantumstring.simulation.FreeString">FreeString</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></b></code>:
<ul class="hlist">
<li><code><a title="quantumstring.simulation.Simulation.infos" href="#quantumstring.simulation.Simulation.infos">infos</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.list2str" href="#quantumstring.simulation.Simulation.list2str">list2str</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.run" href="#quantumstring.simulation.Simulation.run">run</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.size_estimation_mb" href="#quantumstring.simulation.Simulation.size_estimation_mb">size_estimation_mb</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.str2list" href="#quantumstring.simulation.Simulation.str2list">str2list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quantumstring.simulation.RingString"><code class="flex name class">
<span>class <span class="ident">RingString</span></span>
<span>(</span><span>dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, ic0: list[float], ic1: list[float], particles: Particles, log=True, memory_field=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of Simulation: both ends are connected (equivalent of a ring)</p>
<p>Initialisation of the simulation</p>
<p>:param dt: value of the time step [s]
:param time_steps: number of time steps
:param space_steps: number of cells in the string
:param string_len: length of the string [m]
:param string_c: celerity of the string [m/s]
:param string_density: linear density of the string [kg/m]
:param edge_left: the condition at the left extremity of the string
:param edge_right: the condition at the right extremity of the string
:param ic_pos: initial condition of the position of the string
:param ic_vel: initial condition of the velocity of the string
:param particles: Particles object
:param memory_field:
:param log: if True, prints the simulation loading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RingString(Simulation):
    &#34;&#34;&#34;
        Abstraction of Simulation: both ends are connected (equivalent of a ring)
    &#34;&#34;&#34;
    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, ic0: list[float], ic1: list[float], particles: Particles, log=True, memory_field=5):
        ll, lr = LoopEdge(), LoopEdge()
        super().__init__(dt, time_steps, space_steps, string_len, string_density, string_tension, ll, lr, ic0, ic1, particles, log=log, memory_field=memory_field)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></b></code>:
<ul class="hlist">
<li><code><a title="quantumstring.simulation.Simulation.infos" href="#quantumstring.simulation.Simulation.infos">infos</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.list2str" href="#quantumstring.simulation.Simulation.list2str">list2str</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.run" href="#quantumstring.simulation.Simulation.run">run</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.size_estimation_mb" href="#quantumstring.simulation.Simulation.size_estimation_mb">size_estimation_mb</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.str2list" href="#quantumstring.simulation.Simulation.str2list">str2list</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quantumstring.simulation.Simulation"><code class="flex name class">
<span>class <span class="ident">Simulation</span></span>
<span>(</span><span>dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, ic0: list[float], ic1: list[float], particles, memory_field=5, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that wraps the whole simulation thing</p>
<p>Initialisation of the simulation</p>
<p>:param dt: value of the time step [s]
:param time_steps: number of time steps
:param space_steps: number of cells in the string
:param string_len: length of the string [m]
:param string_c: celerity of the string [m/s]
:param string_density: linear density of the string [kg/m]
:param edge_left: the condition at the left extremity of the string
:param edge_right: the condition at the right extremity of the string
:param ic_pos: initial condition of the position of the string
:param ic_vel: initial condition of the velocity of the string
:param particles: Particles object
:param memory_field:
:param log: if True, prints the simulation loading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulation:
    &#34;&#34;&#34;
        Class that wraps the whole simulation thing
    &#34;&#34;&#34;
    IMG_PREFIX = &#34;qs_img___&#34;
    VID_PREFIX = &#34;QuantumString&#34;
    IMG_FORMAT = &#34;png&#34;
    PERCENT_MAX = 256

    STR_DT = &#34;dt&#34;
    STR_DX = &#34;dx&#34;
    STR_TIMESTEPS = &#34;nt&#34;
    STR_SPACESTEPS = &#34;nx&#34;
    STR_TENSION = &#34;T&#34;
    STR_DENSITY = &#34;rho&#34;
    STR_LENGTH = &#34;L&#34;
    STR_EDGE_LEFT = &#34;edge_left&#34;
    STR_EDGE_RIGHT = &#34;edge_right&#34;

    BLACK = (0, 0, 0)
    RED = (255, 0, 0)
    GREEN = (0, 255, 0)
    BLUE = (0, 0, 255)
    GRAY = (64, 64, 64)
    WHITE = (255, 255, 255)

    def __init__(self, dt: float, time_steps: int, space_steps: int, string_len: float, string_density: float, string_tension: float, edge_left: Edge, edge_right: Edge, ic0: list[float], ic1: list[float], particles, memory_field=5, log=True):
        &#34;&#34;&#34;
            Initialisation of the simulation

            :param dt: value of the time step [s]
            :param time_steps: number of time steps
            :param space_steps: number of cells in the string
            :param string_len: length of the string [m]
            :param string_c: celerity of the string [m/s]
            :param string_density: linear density of the string [kg/m]
            :param edge_left: the condition at the left extremity of the string
            :param edge_right: the condition at the right extremity of the string
            :param ic_pos: initial condition of the position of the string
            :param ic_vel: initial condition of the velocity of the string
            :param particles: Particles object
            :param memory_field:
            :param log: if True, prints the simulation loading
        &#34;&#34;&#34;
        self.log = log
        self.time_steps = time_steps
        self.dt = dt
        self.time = str(datetime.datetime.now())

        self.s = PhyString(string_len, space_steps, dt, string_density, string_tension, edge_left, edge_right, ic0, ic1, particles, memory_field=memory_field)
    
    def infos(self) -&gt; dict[str]:
        &#34;&#34;&#34;
            Returns a dictionary containing the informations about the simulation
        &#34;&#34;&#34;
        return {
            &#34;desc&#34;: &#34;QUANTUM STRING SIMULATION&#34;,
            &#34;date&#34;: self.time,
            Simulation.STR_DT: self.s.dt,
            Simulation.STR_DX: self.s.dx,
            Simulation.STR_TIMESTEPS: self.time_steps,
            Simulation.STR_SPACESTEPS: self.s.space_steps,
            Simulation.STR_LENGTH: self.s.length,
            Simulation.STR_TENSION: self.s.tension,
            Simulation.STR_DENSITY: self.s.linear_density,
            Simulation.STR_EDGE_LEFT: str(self.s.edge_left),
            Simulation.STR_EDGE_RIGHT: str(self.s.edge_right),
            &#34;particles&#34;: self.s.particles.infos()
        }
    
    def __repr__(self):
        return &#34;[SIMULATION]    Δt={}s, Δx={}m, time steps={}, space steps={}\n{}\n{}\nEstimation of simulation size = {}MB&#34;.format(
            self.s.dt, 
            self.s.dx, 
            self.time_steps, 
            self.s.space_steps,
            self.s,
            self.s.particles,
            int(self.size_estimation_mb()))

    def run(self, path: str, file=True) -&gt; tuple[str, str]:
        &#34;&#34;&#34;
            Runs the simulation with options to save it as a animation and/or in a file
            Returns the path of the field, particles and energy file generated

            :param path: location where to save the outputs
            :param file: if `True`, saves the simulation to files
        &#34;&#34;&#34;
        dtnow = datetime.datetime.now()
        timestamp = int(dtnow.timestamp())
        jsoninfos = json.dumps(self.infos())
        print(self) if self.log else None

        field_file_path = os.path.join(path, &#34;QuantumString-field_{}.txt&#34;.format(timestamp))
        particles_file_path = os.path.join(path, &#34;QuantumString-particles_{}.txt&#34;.format(timestamp))
        energy_field_path = os.path.join(path, &#34;QuantumString-energy_{}.txt&#34;.format(timestamp))

        begtxt = &#34;{}\n&#34;.format(jsoninfos)

        if file:
            ff = open(field_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)
            pf = open(particles_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)
            ef = open(energy_field_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)

            ff.write(begtxt)
            pf.write(begtxt)
            ef.write(begtxt)

        ts = datetime.datetime.now()
        percent = 0
        list_dt_compute = []
        for t in range(0, self.time_steps):
            if t &gt; 1: # do not update when the timesteps are lower than 1 bc this corresponds to the two initial fields
                self.s.update() # update the string
            
            # printing the update to the console...
            prop = t/self.time_steps
            newpercent = math.floor(prop*Simulation.PERCENT_MAX)
            if (newpercent != percent) and self.log: # update the console
                newts = datetime.datetime.now()
                dtcompute = (newts - ts).total_seconds()
                elapsed = sum(list_dt_compute)
                list_dt_compute.append(dtcompute)
                spinner = &#34;⡀⡁⡂⡃⡄⡅⡆⡇⡈⡉⡊⡋⡌⡍⡎⡏⡐⡑⡒⡓⡔⡕⡖⡗⡘⡙⡚⡛⡜⡝⡞⡟⡠⡡⡢⡣⡤⡥⡦⡧⡨⡩⡪⡫⡬⡭⡮⡯⡰⡱⡲⡳⡴⡵⡶⡷⡸⡹⡺⡻⡼⡽⡾⡿⢀⢁⢂⢃⢄⢅⢆⢇⢈⢉⢊⢋⢌⢍⢎⢏⢐⢑⢒⢓⢔⢕⢖⢗⢘⢙⢚⢛⢜⢝⢞⢟⢠⢡⢢⢣⢤⢥⢦⢧⢨⢩⢪⢫⢬⢭⢮⢯⢰⢱⢲⢳⢴⢵⢶⢷⢸⢹⢺⢻⢼⢽⢾⢿⣀⣁⣂⣃⣄⣅⣆⣇⣈⣉⣊⣋⣌⣍⣎⣏⣐⣑⣒⣓⣔⣕⣖⣗⣘⣙⣚⣛⣜⣝⣞⣟⣠⣡⣢⣣⣤⣥⣦⣧⣨⣩⣪⣫⣬⣭⣮⣯⣰⣱⣲⣳⣴⣵⣶⣷⣸⣹⣺⣻⣼⣽⣾⣿&#34;
                load = percent % len(spinner)
                print(&#34;{:2}% {} {:.4f}s left                &#34;.format(int(percent/Simulation.PERCENT_MAX*100), spinner[load:load+1],  float(elapsed*(1/prop-1))), end=&#34;\r&#34;)
                ts = newts
            percent = newpercent
            # ...
            
            # writing the fields in the files
            f = self.s.field.get_val_time(t)
            pp = self.s.particles.list_pos(tstep=t)
            e = self.s.energy.get_val_time(t)
            
            if file:
                fstr = Simulation.list2str(f)
                pstr = Simulation.list2str(pp)
                estr = Simulation.list2str(e)

                ff.write(&#34;{}\n&#34;.format(fstr))
                pf.write(&#34;{}\n&#34;.format(pstr))
                ef.write(&#34;{}\n&#34;.format(estr))
        print(&#34;&#34;)

        if file:
            ff.close()
            pf.close()
            ef.close()

        return field_file_path, particles_file_path, energy_field_path
    
    def size_estimation_mb(self) -&gt; float:
        &#34;&#34;&#34;
            Gives an estimation of the final size of the field file, in MB (Mo in french)
        &#34;&#34;&#34;
        bytes_per_cell = 21
        return bytes_per_cell*self.s.space_steps*self.time_steps*1e-6

    @staticmethod
    def list2str(l: list) -&gt; str:
        &#34;&#34;&#34;
            Converts a list to a string in a simple format for our use

            ```
            &gt;&gt;&gt; list2str([1, 2, 3])
            &#39;1,2,3&#39;
            ```
        &#34;&#34;&#34;
        return str(list(l)).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34; &#34;, &#34;&#34;).replace(&#34;\n&#34;, &#34;&#34;)
    
    @staticmethod
    def str2list(s: str, type=float) -&gt; list:
        &#34;&#34;&#34;
            Converts a converted string back into a NumPy array. The type of values can be specified

            ```
            &gt;&gt;&gt; str2list(&#34;1,2,3&#34;)
            [1, 2, 3]
            ```
        &#34;&#34;&#34;
        s = s.replace(&#34;\n&#34;, &#34;&#34;)
        l = s.split(&#34;,&#34;)
        return np.array(l).astype(type) if s != &#34;&#34; else np.array([])</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="quantumstring.simulation.Cavity" href="#quantumstring.simulation.Cavity">Cavity</a></li>
<li><a title="quantumstring.simulation.RestString" href="#quantumstring.simulation.RestString">RestString</a></li>
<li><a title="quantumstring.simulation.RingString" href="#quantumstring.simulation.RingString">RingString</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quantumstring.simulation.Simulation.BLACK"><code class="name">var <span class="ident">BLACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.BLUE"><code class="name">var <span class="ident">BLUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.GRAY"><code class="name">var <span class="ident">GRAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.GREEN"><code class="name">var <span class="ident">GREEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.IMG_FORMAT"><code class="name">var <span class="ident">IMG_FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.IMG_PREFIX"><code class="name">var <span class="ident">IMG_PREFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.PERCENT_MAX"><code class="name">var <span class="ident">PERCENT_MAX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.RED"><code class="name">var <span class="ident">RED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_DENSITY"><code class="name">var <span class="ident">STR_DENSITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_DT"><code class="name">var <span class="ident">STR_DT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_DX"><code class="name">var <span class="ident">STR_DX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_EDGE_LEFT"><code class="name">var <span class="ident">STR_EDGE_LEFT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_EDGE_RIGHT"><code class="name">var <span class="ident">STR_EDGE_RIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_LENGTH"><code class="name">var <span class="ident">STR_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_SPACESTEPS"><code class="name">var <span class="ident">STR_SPACESTEPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_TENSION"><code class="name">var <span class="ident">STR_TENSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.STR_TIMESTEPS"><code class="name">var <span class="ident">STR_TIMESTEPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.VID_PREFIX"><code class="name">var <span class="ident">VID_PREFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.simulation.Simulation.WHITE"><code class="name">var <span class="ident">WHITE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="quantumstring.simulation.Simulation.list2str"><code class="name flex">
<span>def <span class="ident">list2str</span></span>(<span>l: list) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a list to a string in a simple format for our use</p>
<pre><code>&gt;&gt;&gt; list2str([1, 2, 3])
'1,2,3'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def list2str(l: list) -&gt; str:
    &#34;&#34;&#34;
        Converts a list to a string in a simple format for our use

        ```
        &gt;&gt;&gt; list2str([1, 2, 3])
        &#39;1,2,3&#39;
        ```
    &#34;&#34;&#34;
    return str(list(l)).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34; &#34;, &#34;&#34;).replace(&#34;\n&#34;, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="quantumstring.simulation.Simulation.str2list"><code class="name flex">
<span>def <span class="ident">str2list</span></span>(<span>s: str, type=builtins.float) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a converted string back into a NumPy array. The type of values can be specified</p>
<pre><code>&gt;&gt;&gt; str2list(&quot;1,2,3&quot;)
[1, 2, 3]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def str2list(s: str, type=float) -&gt; list:
    &#34;&#34;&#34;
        Converts a converted string back into a NumPy array. The type of values can be specified

        ```
        &gt;&gt;&gt; str2list(&#34;1,2,3&#34;)
        [1, 2, 3]
        ```
    &#34;&#34;&#34;
    s = s.replace(&#34;\n&#34;, &#34;&#34;)
    l = s.split(&#34;,&#34;)
    return np.array(l).astype(type) if s != &#34;&#34; else np.array([])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quantumstring.simulation.Simulation.infos"><code class="name flex">
<span>def <span class="ident">infos</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary containing the informations about the simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infos(self) -&gt; dict[str]:
    &#34;&#34;&#34;
        Returns a dictionary containing the informations about the simulation
    &#34;&#34;&#34;
    return {
        &#34;desc&#34;: &#34;QUANTUM STRING SIMULATION&#34;,
        &#34;date&#34;: self.time,
        Simulation.STR_DT: self.s.dt,
        Simulation.STR_DX: self.s.dx,
        Simulation.STR_TIMESTEPS: self.time_steps,
        Simulation.STR_SPACESTEPS: self.s.space_steps,
        Simulation.STR_LENGTH: self.s.length,
        Simulation.STR_TENSION: self.s.tension,
        Simulation.STR_DENSITY: self.s.linear_density,
        Simulation.STR_EDGE_LEFT: str(self.s.edge_left),
        Simulation.STR_EDGE_RIGHT: str(self.s.edge_right),
        &#34;particles&#34;: self.s.particles.infos()
    }</code></pre>
</details>
</dd>
<dt id="quantumstring.simulation.Simulation.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, path: str, file=True) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the simulation with options to save it as a animation and/or in a file
Returns the path of the field, particles and energy file generated</p>
<p>:param path: location where to save the outputs
:param file: if <code>True</code>, saves the simulation to files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, path: str, file=True) -&gt; tuple[str, str]:
    &#34;&#34;&#34;
        Runs the simulation with options to save it as a animation and/or in a file
        Returns the path of the field, particles and energy file generated

        :param path: location where to save the outputs
        :param file: if `True`, saves the simulation to files
    &#34;&#34;&#34;
    dtnow = datetime.datetime.now()
    timestamp = int(dtnow.timestamp())
    jsoninfos = json.dumps(self.infos())
    print(self) if self.log else None

    field_file_path = os.path.join(path, &#34;QuantumString-field_{}.txt&#34;.format(timestamp))
    particles_file_path = os.path.join(path, &#34;QuantumString-particles_{}.txt&#34;.format(timestamp))
    energy_field_path = os.path.join(path, &#34;QuantumString-energy_{}.txt&#34;.format(timestamp))

    begtxt = &#34;{}\n&#34;.format(jsoninfos)

    if file:
        ff = open(field_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)
        pf = open(particles_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)
        ef = open(energy_field_path, &#34;w&#34;, encoding=&#34;utf-8&#34;)

        ff.write(begtxt)
        pf.write(begtxt)
        ef.write(begtxt)

    ts = datetime.datetime.now()
    percent = 0
    list_dt_compute = []
    for t in range(0, self.time_steps):
        if t &gt; 1: # do not update when the timesteps are lower than 1 bc this corresponds to the two initial fields
            self.s.update() # update the string
        
        # printing the update to the console...
        prop = t/self.time_steps
        newpercent = math.floor(prop*Simulation.PERCENT_MAX)
        if (newpercent != percent) and self.log: # update the console
            newts = datetime.datetime.now()
            dtcompute = (newts - ts).total_seconds()
            elapsed = sum(list_dt_compute)
            list_dt_compute.append(dtcompute)
            spinner = &#34;⡀⡁⡂⡃⡄⡅⡆⡇⡈⡉⡊⡋⡌⡍⡎⡏⡐⡑⡒⡓⡔⡕⡖⡗⡘⡙⡚⡛⡜⡝⡞⡟⡠⡡⡢⡣⡤⡥⡦⡧⡨⡩⡪⡫⡬⡭⡮⡯⡰⡱⡲⡳⡴⡵⡶⡷⡸⡹⡺⡻⡼⡽⡾⡿⢀⢁⢂⢃⢄⢅⢆⢇⢈⢉⢊⢋⢌⢍⢎⢏⢐⢑⢒⢓⢔⢕⢖⢗⢘⢙⢚⢛⢜⢝⢞⢟⢠⢡⢢⢣⢤⢥⢦⢧⢨⢩⢪⢫⢬⢭⢮⢯⢰⢱⢲⢳⢴⢵⢶⢷⢸⢹⢺⢻⢼⢽⢾⢿⣀⣁⣂⣃⣄⣅⣆⣇⣈⣉⣊⣋⣌⣍⣎⣏⣐⣑⣒⣓⣔⣕⣖⣗⣘⣙⣚⣛⣜⣝⣞⣟⣠⣡⣢⣣⣤⣥⣦⣧⣨⣩⣪⣫⣬⣭⣮⣯⣰⣱⣲⣳⣴⣵⣶⣷⣸⣹⣺⣻⣼⣽⣾⣿&#34;
            load = percent % len(spinner)
            print(&#34;{:2}% {} {:.4f}s left                &#34;.format(int(percent/Simulation.PERCENT_MAX*100), spinner[load:load+1],  float(elapsed*(1/prop-1))), end=&#34;\r&#34;)
            ts = newts
        percent = newpercent
        # ...
        
        # writing the fields in the files
        f = self.s.field.get_val_time(t)
        pp = self.s.particles.list_pos(tstep=t)
        e = self.s.energy.get_val_time(t)
        
        if file:
            fstr = Simulation.list2str(f)
            pstr = Simulation.list2str(pp)
            estr = Simulation.list2str(e)

            ff.write(&#34;{}\n&#34;.format(fstr))
            pf.write(&#34;{}\n&#34;.format(pstr))
            ef.write(&#34;{}\n&#34;.format(estr))
    print(&#34;&#34;)

    if file:
        ff.close()
        pf.close()
        ef.close()

    return field_file_path, particles_file_path, energy_field_path</code></pre>
</details>
</dd>
<dt id="quantumstring.simulation.Simulation.size_estimation_mb"><code class="name flex">
<span>def <span class="ident">size_estimation_mb</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Gives an estimation of the final size of the field file, in MB (Mo in french)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_estimation_mb(self) -&gt; float:
    &#34;&#34;&#34;
        Gives an estimation of the final size of the field file, in MB (Mo in french)
    &#34;&#34;&#34;
    bytes_per_cell = 21
    return bytes_per_cell*self.s.space_steps*self.time_steps*1e-6</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="quantumstring" href="index.html">quantumstring</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="quantumstring.simulation.Cavity" href="#quantumstring.simulation.Cavity">Cavity</a></code></h4>
</li>
<li>
<h4><code><a title="quantumstring.simulation.CenterFixed" href="#quantumstring.simulation.CenterFixed">CenterFixed</a></code></h4>
</li>
<li>
<h4><code><a title="quantumstring.simulation.FreeString" href="#quantumstring.simulation.FreeString">FreeString</a></code></h4>
</li>
<li>
<h4><code><a title="quantumstring.simulation.RestString" href="#quantumstring.simulation.RestString">RestString</a></code></h4>
</li>
<li>
<h4><code><a title="quantumstring.simulation.RingString" href="#quantumstring.simulation.RingString">RingString</a></code></h4>
</li>
<li>
<h4><code><a title="quantumstring.simulation.Simulation" href="#quantumstring.simulation.Simulation">Simulation</a></code></h4>
<ul class="two-column">
<li><code><a title="quantumstring.simulation.Simulation.BLACK" href="#quantumstring.simulation.Simulation.BLACK">BLACK</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.BLUE" href="#quantumstring.simulation.Simulation.BLUE">BLUE</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.GRAY" href="#quantumstring.simulation.Simulation.GRAY">GRAY</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.GREEN" href="#quantumstring.simulation.Simulation.GREEN">GREEN</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.IMG_FORMAT" href="#quantumstring.simulation.Simulation.IMG_FORMAT">IMG_FORMAT</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.IMG_PREFIX" href="#quantumstring.simulation.Simulation.IMG_PREFIX">IMG_PREFIX</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.PERCENT_MAX" href="#quantumstring.simulation.Simulation.PERCENT_MAX">PERCENT_MAX</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.RED" href="#quantumstring.simulation.Simulation.RED">RED</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_DENSITY" href="#quantumstring.simulation.Simulation.STR_DENSITY">STR_DENSITY</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_DT" href="#quantumstring.simulation.Simulation.STR_DT">STR_DT</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_DX" href="#quantumstring.simulation.Simulation.STR_DX">STR_DX</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_EDGE_LEFT" href="#quantumstring.simulation.Simulation.STR_EDGE_LEFT">STR_EDGE_LEFT</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_EDGE_RIGHT" href="#quantumstring.simulation.Simulation.STR_EDGE_RIGHT">STR_EDGE_RIGHT</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_LENGTH" href="#quantumstring.simulation.Simulation.STR_LENGTH">STR_LENGTH</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_SPACESTEPS" href="#quantumstring.simulation.Simulation.STR_SPACESTEPS">STR_SPACESTEPS</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_TENSION" href="#quantumstring.simulation.Simulation.STR_TENSION">STR_TENSION</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.STR_TIMESTEPS" href="#quantumstring.simulation.Simulation.STR_TIMESTEPS">STR_TIMESTEPS</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.VID_PREFIX" href="#quantumstring.simulation.Simulation.VID_PREFIX">VID_PREFIX</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.WHITE" href="#quantumstring.simulation.Simulation.WHITE">WHITE</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.infos" href="#quantumstring.simulation.Simulation.infos">infos</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.list2str" href="#quantumstring.simulation.Simulation.list2str">list2str</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.run" href="#quantumstring.simulation.Simulation.run">run</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.size_estimation_mb" href="#quantumstring.simulation.Simulation.size_estimation_mb">size_estimation_mb</a></code></li>
<li><code><a title="quantumstring.simulation.Simulation.str2list" href="#quantumstring.simulation.Simulation.str2list">str2list</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>