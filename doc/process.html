<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>quantumstring.process API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quantumstring.process</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import json
import os
import datetime
from io import TextIOWrapper

import cv2
import ffmpeg
import numpy as np
from matplotlib import pyplot as plt
from PIL import Image, ImageDraw, ImageFont
from mpl_toolkits import mplot3d

from quantumstring.field import OneSpaceField
from quantumstring.simulation import Simulation
from quantumstring.particle import Particle, Particles

&#34;&#34;&#34;
    Class for loading a simulation and post process the data
&#34;&#34;&#34;

class PostProcess:
    ANIM_PREFIX = &#34;QuantumStringANIMATION&#34;
    FOURIER_PREFIX = &#34;FourierTransform&#34;
    SPECTRO_PREFIX = &#34;FourierSpectro&#34;

    COLOR_BLACK = (0, 0, 0)
    COLOR_GRAY = (192, 192, 192)
    COLOR_WHITE = (255, 255, 255)
    COLOR_RED = (0, 0, 255)
    COLOR_GREEN = (0, 255, 0)
    COLOR_BLUE = (255, 0, 0)

    def __init__(self, fieldfile: TextIOWrapper, particlesfile: TextIOWrapper, energyfile: TextIOWrapper, log=True):
        &#34;&#34;&#34;
            :param fieldfile: simulation file of field
            :param particlesfile: simulation file of particles
            :param energyfile: simulation file of energy
        &#34;&#34;&#34;
        self.log = log

        self.fieldfile = fieldfile
        self.particlesfile = particlesfile
        self.energyfile = energyfile

        self.infos = json.loads(fieldfile.readline()) # loads the first line to gather the infos about the simulation
        self.date = self.infos[&#34;date&#34;]
        self.dx = self.infos[Simulation.STR_DX]
        self.dt = self.infos[Simulation.STR_DT]
        self.nx = self.infos[Simulation.STR_SPACESTEPS]
        self.nt = self.infos[Simulation.STR_TIMESTEPS]
        self.L = self.infos[Simulation.STR_LENGTH]
        self.rho = self.infos[Simulation.STR_DENSITY]
        self.T = self.infos[Simulation.STR_TENSION]
        self.left = self.infos[Simulation.STR_EDGE_LEFT]
        self.right = self.infos[Simulation.STR_EDGE_RIGHT]
        self.duration = self.dt*self.nt
        self.particles = self.infos[&#34;particles&#34;]

        self.c = np.sqrt(self.T/self.rho)
    
    def energy(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Draws a graph of the total energy of the field in function of time.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        self.energyfile.seek(0, 0)
        nrj_tot = []

        t = -1
        for energyline in self.energyfile:
            if t &gt;= 0:
                e = Simulation.str2list(energyline)
                nrj_tot.append(np.sum(e)*self.dx)
            t += 1
        
        tline = np.linspace(0.0, self.duration, self.nt)

        ax = plt.axes()
        ax.plot(tline, nrj_tot, &#34;.&#34;, label=label)
        ax.set_title(&#34;Total energy of the string (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;t [s]&#34;)
        ax.set_ylabel(&#34;Energy [J]&#34;)
        ax.legend() if label != &#34;&#34; else None
        plt.show() if show else None
    
    def plot_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Plots a graph of the vertical position of the field where the particles are versus the time.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        pp = self._particles_pos()
        tline = np.linspace(0, self.duration, self.nt)
        for pos, part in zip(pp.T, self.particles):
            c = np.flip(np.array(part[Particle.STR_COLOR])/255.0)
            ax.plot(tline, pos, color=tuple(c))
            ax.legend([label]) if label != &#34;&#34; else None
        ax.set_title(&#34;Particles vertical position (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;t [s]&#34;)
        ax.set_ylabel(&#34;z [m]&#34;)
        plt.show() if show else None
    
    def phasegraph_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Plots a graph of the derivative of the vertical position of the field, versus the actual vertical position of the field.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        pp = self._particles_pos()
        for pos, part in zip(pp.T, self.particles):
            dpos = np.gradient(pos, self.dt)
            c = np.flip(np.array(part[Particle.STR_COLOR])/255.0)
            ax.plot(pos, dpos, marker=&#34;.&#34;, color=tuple(c))
            ax.legend([label])
        ax.set_title(&#34;Particles phase graph (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;$z$ [m]&#34;)
        ax.set_ylabel(&#34;$\\frac{\partial z}{\partial t}$ [m/s]&#34;)
        plt.show() if show else None
    
    def plot_grad_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Draws a graph of the gradient near the particle. 
            Solid line for the left gradient, dashed line for right gradient.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;

        ax.set_title(&#34;Gradient at left (solid) and right (dashed) to the particles&#34;)
        ax.set_xlabel(&#34;$t [s]$&#34;)
        ax.set_ylabel(&#34;$\frac{\partial u}{\partial x}$&#34;)

        tline = np.linspace(0.0, self.duration, self.nt)
        for part in self.particles:
            cell = part[Particle.STR_INIT_POS]
            color = part[Particle.STR_COLOR]
            l, r = cell - 1, cell + 1
            vpart = self._get_cells(l, cell, r)

            grad_left = (vpart[:,1] - vpart[:,0])/self.dx
            grad_right = (vpart[:,2] - vpart[:,1])/self.dx

            ax.plot(tline, grad_left, linestyle=&#34;solid&#34;, color=color)
            ax.plot(tline, grad_right, linestyle=&#34;dashed&#34;, color=color)
        
        plt.show() if show else None
    
    @staticmethod
    def file2matrix(file: TextIOWrapper, type=float) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Given a file generated using the `quantum-string` library, converts and returns the data as a 2D NumPy array

            :param file: Python opened file
            :param type: type of the numbers inside the file (`int`, `float`, `np.complex`...)
        &#34;&#34;&#34;
        file.seek(0, 0)
        r = []
        t = -1
        for field in file:
            if t &gt;= 0:
                try:
                    line = Simulation.str2list(field, type=type) if field != &#34;\n&#34; else None
                    r.append(line) 
                except:
                    raise ValueError(&#34;File given has some errors or is not from a simulation! Please check the file.\n Problem at line {} with &#39;{}&#39;&#34;.format(t + 1, field))
            t += 1
        return np.array(r)
    
    def _get_cells(self, *cells: int) -&gt; np.ndarray:
        self.fieldfile.seek(0, 0)
        r = []
        t = -1
        for field in self.fieldfile:
            if t &gt;= 0:
                field = Simulation.str2list(field, type=float)
                line = []
                for c in cells:
                    try:
                        line.append(field[c])
                    except: # probably end of file
                        pass
                r.append(line) if len(line) != 0 else None
            t += 1
        return np.array(r)
    
    def plot_cells(self, *cells: int, ax=plt.axes(), show=True) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Draws a graph of the value of the cells given, in function of time

            :param cells: cells to draw the value
            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        cells_vals = self._get_cells(*cells)
        ax.set_title(&#34;Cells plotting (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;t [s]&#34;)
        ax.set_ylabel(&#34;u [m]&#34;)

        tline = np.linspace(0.0, self.duration, self.nt)
        for c, idx in zip(cells_vals.T, cells):
            ax.plot(tline, c, label=&#34;x={}m&#34;.format(idx*self.dx))
            ax.legend()
        
        plt.plot() if show else None
        
    def _particles_pos(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Returns a 2D array r[t,n] where r is the position of the particle, t the timestep considered, and n the index of the particle
        &#34;&#34;&#34;
        self.fieldfile.seek(0, 0)
        self.particlesfile.seek(0, 0)
        r = []

        t = -1
        for field, particles in zip(self.fieldfile, self.particlesfile):
            if t &gt;= 0:
                field = Simulation.str2list(field, type=float)
                particles = Simulation.str2list(particles, type=int)
                pos_part = []
                for pos in particles:
                    pos_part.append(field[pos])
                pos_part = np.array(pos_part)
                r.append(pos_part)
            t += 1
        return np.array(r)
    
    def _img_field(self, baseimg: np.ndarray, f: list[float], p: list[int], anim_params: dict, timestep: int, yscale=1.0) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Create and returns an image of the current state of the simulation

            :param baseimg: base PIL Image to write onto
            :param f: state of the string
            :param p: the position (cell) of each particles
            :param anim_params: dictionary containing the parameters of the animation
            :param timestep: time step corresponding to the state
            :param yscale: scaling factor for vertical axis
        &#34;&#34;&#34;
        img = np.copy(baseimg)
        x = np.linspace(anim_params[&#34;ox&#34;], anim_params[&#34;endstring&#34;], f.size).astype(np.int32)
        y = (-anim_params[&#34;ppx_per_m&#34;]*yscale*f + anim_params[&#34;oy&#34;]).astype(np.int32)
        string = np.array([(x[i], y[i]) for i in range(1, f.size - 1)])
        string = string.reshape((-1, 1, 2))

        cv2.polylines(img, [string], False, PostProcess.COLOR_WHITE)
        font = cv2.FONT_HERSHEY_SIMPLEX
        cv2.putText(img, &#34;t={:.6f}s&#34;.format(self.dt*timestep), (2, anim_params[&#34;ly&#34;] - 5), font, 0.5, PostProcess.COLOR_GRAY, 1, cv2.LINE_AA) 

        r = int(anim_params[&#34;mass_rad&#34;])
        for pidx, part in zip(p, self.particles):
            center = (int(x[pidx]), int(y[pidx]))
            try:
                cv2.circle(img, center, r, part[Particle.STR_COLOR], -1)
            except IndexError:
                pass

        try:
            img[y[0], x[0]] = PostProcess.COLOR_GRAY
            img[y[len(y)-1], x[len(x)-1]] = PostProcess.COLOR_GRAY
        except IndexError:
            pass
        
        return img

    def anim(self, path: str, title=False, resolution=(720, 480), fps=60, frameskip=1, yscale=1.0, compress=True):
        &#34;&#34;&#34;
            Creates a animation of the simulation, using `opencv`

            :param path: path where to write the video
            :param title: a title for the video. if `False`, automatic name
            :param fps: frame per seconds for the generated video
            :param frameskip: will compute 1 out of `frameskip` frames for the generated video
            :param yscale: vertical scaling for field
            :param compress: if `True`, will try to compress the video using `ffmeg`
        &#34;&#34;&#34;
        ts = int(datetime.datetime.now().timestamp())
        self.fieldfile.seek(0, 0)
        self.particlesfile.seek(0, 0)

        title = PostProcess.ANIM_PREFIX if type(title) == bool and not title else title
        videopath = os.path.join(path, &#34;{}-{}-UNCOMPRESSED.mp4&#34;.format(title, ts))
        videopath_compressed = os.path.join(path, &#34;{}-{}.mp4&#34;.format(title, ts))

        lx, ly = resolution[0], resolution[1]
        margin_ppx = 5
        length_ppx = lx - 2*margin_ppx
        anim_params = dict(
            lx=lx,
            ly=ly,
            ox=margin_ppx,
            oy=0.5*ly,
            endstring=margin_ppx + length_ppx,
            ppx_per_m=length_ppx,
            mass_rad=3
        )

        baseimg = np.zeros((resolution[1], resolution[0], 3), np.uint8)

        textinfos = &#34;L={:.2f}m ρ={:.2f}g/m T={:.2f}N c={:.2f}m/s\n{} ~ {}&#34;.format(
            self.L, 
            self.rho*1e3, 
            self.T, 
            np.sqrt(self.T/self.rho),
            self.left,
            self.right
            )
        
        fontpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), &#34;Roboto-Regular.ttf&#34;)
        font = ImageFont.truetype(fontpath, 16)
        img_pil = Image.fromarray(baseimg)
        draw = ImageDraw.Draw(img_pil)
        draw.multiline_text((2, 2), textinfos, font=font, fill=PostProcess.COLOR_GRAY)
        lineh = 12
        hcount = 0
        for p, count in zip(self.particles, range(0, len(self.particles))):
            textparticle = &#34;m={:.1f}g, ω={:.1f}rad/s&#34;.format(p[Particle.STR_MASS]*1e3, p[Particle.STR_PULSATION])
            c = tuple(p[Particle.STR_COLOR])
            draw.text((lx - 200, 2 + hcount), textparticle, font=font, fill=c)
            hcount += lineh
            if count &gt; 4:
                break
        baseimg = np.array(img_pil)

        video = cv2.VideoWriter(videopath, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;), fps, (lx, ly))

        print(&#34;Animation for {} simulation:&#34;.format(self.date)) if self.log else None
        t = -1
        for field, particles in zip(self.fieldfile, self.particlesfile):
            if t &gt;= 0: # the file has a one-line header (json format)
                print(&#34;{}/{} images processed&#34;.format(int(t/frameskip), int(self.nt/frameskip)), end=&#34;\r&#34;) if self.log else None
                field = Simulation.str2list(field, type=float)
                particles = Simulation.str2list(particles, type=int)
                if t%frameskip == 0:
                    img = self._img_field(baseimg, field, particles, anim_params, t, yscale=yscale)
                    video.write(img)
            t += 1
        
        video.release()
        cv2.destroyAllWindows()

        return_path = videopath
        if compress:
            try:
                video = ffmpeg.input(videopath)
                video = ffmpeg.output(video, videopath_compressed, vcodec=&#34;h264&#34;)
                ffmpeg.run(video)
                os.remove(videopath)
                return_path = videopath_compressed
            except:
                print(&#34;WARNING: could not compress the video due to &#39;ffmpeg&#39; error...&#34;) if self.log else None

        print(&#34;video created successfully!&#34;) if self.log else None
        return return_path
    
    @staticmethod
    def reduce_axis(mat: np.ndarray, factor: int, axis=0):
        &#34;&#34;&#34;
            Given a matrix (an×m) or (n×am), returns a matrix (n×m) where the cells are the means of the cells surroundings

            ```
            &gt;&gt;&gt; mat = np.array([
                [0, 1, 2, 3],
                [4, 5, 6, 7],
                [8, 9, 10, 11],
                [12, 13, 14, 15]
            ])
            &gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=0)
            &gt;&gt;&gt; np.array([
                [0+4, 1+5, 2+6, 3+7],
                [8+12, 9+13, 10+14, 11+15]
            ])/2
            &gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=1)
            &gt;&gt;&gt; np.array([
                [0+1, 2+3],
                [4+5, 6+7],
                [8+9, 10+11],
                [12+13, 14+15]
            ])/2
            ```
        &#34;&#34;&#34;
        complementary = 1 if axis == 0 else 0
        s = mat.shape[complementary]
        q = mat.shape[axis]

        if s%factor != 0:
            raise ValueError(&#34;Error with matrix shape: {} is not a multiple of {}&#34;.format(s, factor))

        l = np.eye(int(q), dtype=float)
        r = np.repeat(np.eye(int(s/factor), dtype=float), repeats=factor, axis=axis)
        if axis:
            l, r = r, l
        
        return l.dot(mat).dot(r)/factor
    
    @staticmethod
    def _prime_factors(num: int) -&gt; list[int]:  
        primes = []
        # Using the while loop, we will print the number of two&#39;s that divide n  
        while num%2 == 0:  
            primes.append(2) 
            num = int(num*0.5)
    
        for i in range(3, int(np.sqrt(num)) + 1, 2):  
            # while i divides n , print i ad divide n  
            while num%i == 0:  
                primes.append(i)
                num = int(num/i)  
        
        if num &gt; 2:
            primes.append(num)

        return primes

    @staticmethod
    def _all_subsets(*el: object) -&gt; list:
        n = len(el)
        subsets = []
        for i in range(0, 2**n):
            bin_str = bin(i).replace(&#34;0b&#34;, &#34;&#34;).zfill(n)
            current = []
            for b, idx in zip(bin_str, range(0, len(bin_str))):
                b = int(b)
                if b:
                    current.append(el[idx])
            subsets.append(current)
        return subsets

    @staticmethod
    def _reduce_space(mat: np.ndarray, ideal_size: tuple[int]) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Reduces a given matrix doing the mean method, by a factor close to the one given in argument. If no factor is given, the highest possible will be made
        &#34;&#34;&#34;
        for i, ideal, axis in zip(mat.shape, ideal_size, (1, 0)):
            primes = PostProcess._prime_factors(i)[0:16] # we take no more than 16 primes, otherwise the subsets will be too long to compute...
            subsets = PostProcess._all_subsets(*primes)
            all_factors = []
            for sub in subsets:
                nb = np.prod(sub)
                all_factors.append(nb)
            all_factors = np.array(all_factors)
            factor = all_factors[np.abs(i/all_factors - ideal).argmin()]
            mat = PostProcess.reduce_axis(mat, factor, axis=axis) if i &gt; ideal else mat

        return mat
    
    def _get_field(self, matrix_ideal_res: int) -&gt; tuple[np.ndarray]:
        self.fieldfile.seek(0, 0)
        Z = [] # mat[t,x]
        t = -1
        for f in self.fieldfile:
            if t &gt;= 0:
                Z.append(Simulation.str2list(f))
            t =+ 1
        Z = np.array(Z)

        ideal_size = (matrix_ideal_res, matrix_ideal_res) # Z matrix is often too large to be plot correctly...
        Z = PostProcess._reduce_space(Z, ideal_size) if matrix_ideal_res &lt; np.inf else Z
        tsize, xsize = Z.shape

        xline = np.linspace(0.0, self.L, xsize)
        tline = np.linspace(0.0, self.duration*self.c, tsize)
        X, T = np.meshgrid(xline, tline)

        return X.T, T.T, Z.T

    def plot3d(self, ax=plt.axes(), show=True, matrix_ideal_res=128, cmap=&#34;viridis&#34;):
        &#34;&#34;&#34;
            Draws a graph of the values of the field as a function of time, as a 3D graph

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
            :param matrix_ideal_res: ideal resolution for the matrix to plot
            :param cmap: colormap of the graph
        &#34;&#34;&#34;

        fig = plt.figure()
        ax = plt.axes(projection=&#39;3d&#39;)
        ax.plot_surface(*self._get_field(matrix_ideal_res),
                rstride=1, cstride=1,
                cmap=cmap, edgecolor=&#39;none&#39;)
        ax.set_title(&#34;Graph evolution of the field (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;x [m]&#34;)
        ax.set_ylabel(&#34;ct [m]&#34;)
        ax.set_zlabel(&#34;u [m]&#34;)
        plt.show() if show else None
    
    def plot2d(self, ax=plt.axes(), show=True, matrix_ideal_res=np.inf, cmap=&#34;viridis&#34;):
        &#34;&#34;&#34;
            Draws a graph of the values of the field as a function of time, as a 2D colored graph

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
            :param matrix_ideal_res: ideal resolution for the matrix to plot
            :param cmap: colormap of the graph
        &#34;&#34;&#34;
        im = ax.pcolormesh(*self._get_field(matrix_ideal_res),
                cmap=cmap,
                rasterized=True)
        ax.set_title(&#34;Color mesh of the field (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;x [m]&#34;)
        ax.set_ylabel(&#34;ct [m]&#34;)
        ax.colorbar(im, ax=ax)
        plt.show() if show else None

    def fourier(self, *windows, frameskip=1, spectrograph=True, path=os.path.dirname(os.path.abspath(__file__))) -&gt; list[str]:
        &#34;&#34;&#34;
            Computes the spatial FFT of the field, in each given window, for all times. 

            :param windows: list of tuples that represents the windows (dimensionless values) where to compute
            :param frameskip: ill compute 1 out of `frameskip` frames for the FFT
            :param spectrograph: if `True` will generate and save a spectrograph of the FFT for each window in path
            :param path: path where to save the FFT
        &#34;&#34;&#34;
        ts = int(datetime.datetime.now().timestamp())
        self.fieldfile.seek(0, 0)
        self.particlesfile.seek(0, 0)
        r = []
        transforms = dict()
        if len(windows) == 0: # if no window given, take the whole string
            windows = [(0.0, 1.0)]
        for w in windows:
            key = str(w)
            transforms[key] = {}
            a, b = int(w[0]*self.nx), int(w[1]*self.nx)
            transforms[key][&#34;window_cells&#34;] = (a, b)
            transforms[key][&#34;mat&#34;] = np.array([[0.0]*(b - a)])
            filename = &#34;{}_{}{}.txt&#34;.format(ts, PostProcess.FOURIER_PREFIX, key)
            filepath = os.path.join(path, filename)
            r.append(filepath)
            file = open(filepath, &#34;w&#34;)
            transforms[key][&#34;file&#34;] = file
            copyinfos = self.infos.copy()
            copyinfos[&#34;fourier&#34;] = dict(window_cells=(a, b))
            file.write(&#34;{}\n&#34;.format(json.dumps(copyinfos)))

        osf = OneSpaceField(np.array([[0.0]*self.nx]), memory=3)
        frames = 0
        t = -1

        print(&#34;processing FFT...&#34;) if self.log else None
        for line in self.fieldfile:
            print(&#34;{}/{}&#34;.format(t, self.duration/self.dt), end=&#34;\r&#34;) if self.log else None
            if t &gt;= 0: # the file has a one-line header (json format)
                field = Simulation.str2list(line)
                osf.update(field)
                for tm in transforms.values():
                    towrite = &#34;&#34;
                    if t%frameskip == 0:
                        a, b = tm[&#34;window_cells&#34;]
                        mat = tm[&#34;mat&#34;]
                        fft, tm[&#34;f&#34;] = osf.space_fft(-1, self.infos[&#34;dx&#34;], xwindow=(a, b))
                        tm[&#34;mat&#34;] = np.append(mat, [fft], axis=0)
                        towrite = Simulation.list2str(fft)
                    tm[&#34;file&#34;].write(&#34;{}\n&#34;.format(towrite))
                    frames = tm[&#34;mat&#34;].shape[0] - 1
            t += 1

        time = np.linspace(0.0, self.duration, frames)
        
        if spectrograph:
            print(&#34;creating spectrograph...&#34;) if self.log else None
            for key, tm in transforms.items(): # creating the spectrography
                tm[&#34;file&#34;].close()
                f = tm[&#34;f&#34;]
                mat = tm[&#34;mat&#34;]
                ff, tt = np.meshgrid(f, time)
                mat = np.delete(mat, 0, 0)
                plt.pcolormesh(tt, ff, np.abs(mat), shading=&#34;gouraud&#34;)
                plt.title(key)
                plt.xlabel(&#34;Time [s]&#34;)
                plt.ylabel(&#34;Space frequency [rad/m]&#34;)
                pathsave = os.path.join(path, &#34;{}-{}-{}.png&#34;.format(PostProcess.SPECTRO_PREFIX, key, ts))
                plt.savefig(pathsave, dpi=1024)
                plt.close()
                print(&#34;&#39;{}&#39; successfully created&#34;.format(pathsave))
        
        return r</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="quantumstring.process.PostProcess"><code class="flex name class">
<span>class <span class="ident">PostProcess</span></span>
<span>(</span><span>fieldfile: TextIOWrapper, particlesfile: TextIOWrapper, energyfile: TextIOWrapper, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>:param fieldfile: simulation file of field
:param particlesfile: simulation file of particles
:param energyfile: simulation file of energy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostProcess:
    ANIM_PREFIX = &#34;QuantumStringANIMATION&#34;
    FOURIER_PREFIX = &#34;FourierTransform&#34;
    SPECTRO_PREFIX = &#34;FourierSpectro&#34;

    COLOR_BLACK = (0, 0, 0)
    COLOR_GRAY = (192, 192, 192)
    COLOR_WHITE = (255, 255, 255)
    COLOR_RED = (0, 0, 255)
    COLOR_GREEN = (0, 255, 0)
    COLOR_BLUE = (255, 0, 0)

    def __init__(self, fieldfile: TextIOWrapper, particlesfile: TextIOWrapper, energyfile: TextIOWrapper, log=True):
        &#34;&#34;&#34;
            :param fieldfile: simulation file of field
            :param particlesfile: simulation file of particles
            :param energyfile: simulation file of energy
        &#34;&#34;&#34;
        self.log = log

        self.fieldfile = fieldfile
        self.particlesfile = particlesfile
        self.energyfile = energyfile

        self.infos = json.loads(fieldfile.readline()) # loads the first line to gather the infos about the simulation
        self.date = self.infos[&#34;date&#34;]
        self.dx = self.infos[Simulation.STR_DX]
        self.dt = self.infos[Simulation.STR_DT]
        self.nx = self.infos[Simulation.STR_SPACESTEPS]
        self.nt = self.infos[Simulation.STR_TIMESTEPS]
        self.L = self.infos[Simulation.STR_LENGTH]
        self.rho = self.infos[Simulation.STR_DENSITY]
        self.T = self.infos[Simulation.STR_TENSION]
        self.left = self.infos[Simulation.STR_EDGE_LEFT]
        self.right = self.infos[Simulation.STR_EDGE_RIGHT]
        self.duration = self.dt*self.nt
        self.particles = self.infos[&#34;particles&#34;]

        self.c = np.sqrt(self.T/self.rho)
    
    def energy(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Draws a graph of the total energy of the field in function of time.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        self.energyfile.seek(0, 0)
        nrj_tot = []

        t = -1
        for energyline in self.energyfile:
            if t &gt;= 0:
                e = Simulation.str2list(energyline)
                nrj_tot.append(np.sum(e)*self.dx)
            t += 1
        
        tline = np.linspace(0.0, self.duration, self.nt)

        ax = plt.axes()
        ax.plot(tline, nrj_tot, &#34;.&#34;, label=label)
        ax.set_title(&#34;Total energy of the string (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;t [s]&#34;)
        ax.set_ylabel(&#34;Energy [J]&#34;)
        ax.legend() if label != &#34;&#34; else None
        plt.show() if show else None
    
    def plot_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Plots a graph of the vertical position of the field where the particles are versus the time.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        pp = self._particles_pos()
        tline = np.linspace(0, self.duration, self.nt)
        for pos, part in zip(pp.T, self.particles):
            c = np.flip(np.array(part[Particle.STR_COLOR])/255.0)
            ax.plot(tline, pos, color=tuple(c))
            ax.legend([label]) if label != &#34;&#34; else None
        ax.set_title(&#34;Particles vertical position (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;t [s]&#34;)
        ax.set_ylabel(&#34;z [m]&#34;)
        plt.show() if show else None
    
    def phasegraph_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Plots a graph of the derivative of the vertical position of the field, versus the actual vertical position of the field.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        pp = self._particles_pos()
        for pos, part in zip(pp.T, self.particles):
            dpos = np.gradient(pos, self.dt)
            c = np.flip(np.array(part[Particle.STR_COLOR])/255.0)
            ax.plot(pos, dpos, marker=&#34;.&#34;, color=tuple(c))
            ax.legend([label])
        ax.set_title(&#34;Particles phase graph (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;$z$ [m]&#34;)
        ax.set_ylabel(&#34;$\\frac{\partial z}{\partial t}$ [m/s]&#34;)
        plt.show() if show else None
    
    def plot_grad_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
        &#34;&#34;&#34;
            Draws a graph of the gradient near the particle. 
            Solid line for the left gradient, dashed line for right gradient.

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;

        ax.set_title(&#34;Gradient at left (solid) and right (dashed) to the particles&#34;)
        ax.set_xlabel(&#34;$t [s]$&#34;)
        ax.set_ylabel(&#34;$\frac{\partial u}{\partial x}$&#34;)

        tline = np.linspace(0.0, self.duration, self.nt)
        for part in self.particles:
            cell = part[Particle.STR_INIT_POS]
            color = part[Particle.STR_COLOR]
            l, r = cell - 1, cell + 1
            vpart = self._get_cells(l, cell, r)

            grad_left = (vpart[:,1] - vpart[:,0])/self.dx
            grad_right = (vpart[:,2] - vpart[:,1])/self.dx

            ax.plot(tline, grad_left, linestyle=&#34;solid&#34;, color=color)
            ax.plot(tline, grad_right, linestyle=&#34;dashed&#34;, color=color)
        
        plt.show() if show else None
    
    @staticmethod
    def file2matrix(file: TextIOWrapper, type=float) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Given a file generated using the `quantum-string` library, converts and returns the data as a 2D NumPy array

            :param file: Python opened file
            :param type: type of the numbers inside the file (`int`, `float`, `np.complex`...)
        &#34;&#34;&#34;
        file.seek(0, 0)
        r = []
        t = -1
        for field in file:
            if t &gt;= 0:
                try:
                    line = Simulation.str2list(field, type=type) if field != &#34;\n&#34; else None
                    r.append(line) 
                except:
                    raise ValueError(&#34;File given has some errors or is not from a simulation! Please check the file.\n Problem at line {} with &#39;{}&#39;&#34;.format(t + 1, field))
            t += 1
        return np.array(r)
    
    def _get_cells(self, *cells: int) -&gt; np.ndarray:
        self.fieldfile.seek(0, 0)
        r = []
        t = -1
        for field in self.fieldfile:
            if t &gt;= 0:
                field = Simulation.str2list(field, type=float)
                line = []
                for c in cells:
                    try:
                        line.append(field[c])
                    except: # probably end of file
                        pass
                r.append(line) if len(line) != 0 else None
            t += 1
        return np.array(r)
    
    def plot_cells(self, *cells: int, ax=plt.axes(), show=True) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Draws a graph of the value of the cells given, in function of time

            :param cells: cells to draw the value
            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
        &#34;&#34;&#34;
        cells_vals = self._get_cells(*cells)
        ax.set_title(&#34;Cells plotting (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;t [s]&#34;)
        ax.set_ylabel(&#34;u [m]&#34;)

        tline = np.linspace(0.0, self.duration, self.nt)
        for c, idx in zip(cells_vals.T, cells):
            ax.plot(tline, c, label=&#34;x={}m&#34;.format(idx*self.dx))
            ax.legend()
        
        plt.plot() if show else None
        
    def _particles_pos(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Returns a 2D array r[t,n] where r is the position of the particle, t the timestep considered, and n the index of the particle
        &#34;&#34;&#34;
        self.fieldfile.seek(0, 0)
        self.particlesfile.seek(0, 0)
        r = []

        t = -1
        for field, particles in zip(self.fieldfile, self.particlesfile):
            if t &gt;= 0:
                field = Simulation.str2list(field, type=float)
                particles = Simulation.str2list(particles, type=int)
                pos_part = []
                for pos in particles:
                    pos_part.append(field[pos])
                pos_part = np.array(pos_part)
                r.append(pos_part)
            t += 1
        return np.array(r)
    
    def _img_field(self, baseimg: np.ndarray, f: list[float], p: list[int], anim_params: dict, timestep: int, yscale=1.0) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Create and returns an image of the current state of the simulation

            :param baseimg: base PIL Image to write onto
            :param f: state of the string
            :param p: the position (cell) of each particles
            :param anim_params: dictionary containing the parameters of the animation
            :param timestep: time step corresponding to the state
            :param yscale: scaling factor for vertical axis
        &#34;&#34;&#34;
        img = np.copy(baseimg)
        x = np.linspace(anim_params[&#34;ox&#34;], anim_params[&#34;endstring&#34;], f.size).astype(np.int32)
        y = (-anim_params[&#34;ppx_per_m&#34;]*yscale*f + anim_params[&#34;oy&#34;]).astype(np.int32)
        string = np.array([(x[i], y[i]) for i in range(1, f.size - 1)])
        string = string.reshape((-1, 1, 2))

        cv2.polylines(img, [string], False, PostProcess.COLOR_WHITE)
        font = cv2.FONT_HERSHEY_SIMPLEX
        cv2.putText(img, &#34;t={:.6f}s&#34;.format(self.dt*timestep), (2, anim_params[&#34;ly&#34;] - 5), font, 0.5, PostProcess.COLOR_GRAY, 1, cv2.LINE_AA) 

        r = int(anim_params[&#34;mass_rad&#34;])
        for pidx, part in zip(p, self.particles):
            center = (int(x[pidx]), int(y[pidx]))
            try:
                cv2.circle(img, center, r, part[Particle.STR_COLOR], -1)
            except IndexError:
                pass

        try:
            img[y[0], x[0]] = PostProcess.COLOR_GRAY
            img[y[len(y)-1], x[len(x)-1]] = PostProcess.COLOR_GRAY
        except IndexError:
            pass
        
        return img

    def anim(self, path: str, title=False, resolution=(720, 480), fps=60, frameskip=1, yscale=1.0, compress=True):
        &#34;&#34;&#34;
            Creates a animation of the simulation, using `opencv`

            :param path: path where to write the video
            :param title: a title for the video. if `False`, automatic name
            :param fps: frame per seconds for the generated video
            :param frameskip: will compute 1 out of `frameskip` frames for the generated video
            :param yscale: vertical scaling for field
            :param compress: if `True`, will try to compress the video using `ffmeg`
        &#34;&#34;&#34;
        ts = int(datetime.datetime.now().timestamp())
        self.fieldfile.seek(0, 0)
        self.particlesfile.seek(0, 0)

        title = PostProcess.ANIM_PREFIX if type(title) == bool and not title else title
        videopath = os.path.join(path, &#34;{}-{}-UNCOMPRESSED.mp4&#34;.format(title, ts))
        videopath_compressed = os.path.join(path, &#34;{}-{}.mp4&#34;.format(title, ts))

        lx, ly = resolution[0], resolution[1]
        margin_ppx = 5
        length_ppx = lx - 2*margin_ppx
        anim_params = dict(
            lx=lx,
            ly=ly,
            ox=margin_ppx,
            oy=0.5*ly,
            endstring=margin_ppx + length_ppx,
            ppx_per_m=length_ppx,
            mass_rad=3
        )

        baseimg = np.zeros((resolution[1], resolution[0], 3), np.uint8)

        textinfos = &#34;L={:.2f}m ρ={:.2f}g/m T={:.2f}N c={:.2f}m/s\n{} ~ {}&#34;.format(
            self.L, 
            self.rho*1e3, 
            self.T, 
            np.sqrt(self.T/self.rho),
            self.left,
            self.right
            )
        
        fontpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), &#34;Roboto-Regular.ttf&#34;)
        font = ImageFont.truetype(fontpath, 16)
        img_pil = Image.fromarray(baseimg)
        draw = ImageDraw.Draw(img_pil)
        draw.multiline_text((2, 2), textinfos, font=font, fill=PostProcess.COLOR_GRAY)
        lineh = 12
        hcount = 0
        for p, count in zip(self.particles, range(0, len(self.particles))):
            textparticle = &#34;m={:.1f}g, ω={:.1f}rad/s&#34;.format(p[Particle.STR_MASS]*1e3, p[Particle.STR_PULSATION])
            c = tuple(p[Particle.STR_COLOR])
            draw.text((lx - 200, 2 + hcount), textparticle, font=font, fill=c)
            hcount += lineh
            if count &gt; 4:
                break
        baseimg = np.array(img_pil)

        video = cv2.VideoWriter(videopath, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;), fps, (lx, ly))

        print(&#34;Animation for {} simulation:&#34;.format(self.date)) if self.log else None
        t = -1
        for field, particles in zip(self.fieldfile, self.particlesfile):
            if t &gt;= 0: # the file has a one-line header (json format)
                print(&#34;{}/{} images processed&#34;.format(int(t/frameskip), int(self.nt/frameskip)), end=&#34;\r&#34;) if self.log else None
                field = Simulation.str2list(field, type=float)
                particles = Simulation.str2list(particles, type=int)
                if t%frameskip == 0:
                    img = self._img_field(baseimg, field, particles, anim_params, t, yscale=yscale)
                    video.write(img)
            t += 1
        
        video.release()
        cv2.destroyAllWindows()

        return_path = videopath
        if compress:
            try:
                video = ffmpeg.input(videopath)
                video = ffmpeg.output(video, videopath_compressed, vcodec=&#34;h264&#34;)
                ffmpeg.run(video)
                os.remove(videopath)
                return_path = videopath_compressed
            except:
                print(&#34;WARNING: could not compress the video due to &#39;ffmpeg&#39; error...&#34;) if self.log else None

        print(&#34;video created successfully!&#34;) if self.log else None
        return return_path
    
    @staticmethod
    def reduce_axis(mat: np.ndarray, factor: int, axis=0):
        &#34;&#34;&#34;
            Given a matrix (an×m) or (n×am), returns a matrix (n×m) where the cells are the means of the cells surroundings

            ```
            &gt;&gt;&gt; mat = np.array([
                [0, 1, 2, 3],
                [4, 5, 6, 7],
                [8, 9, 10, 11],
                [12, 13, 14, 15]
            ])
            &gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=0)
            &gt;&gt;&gt; np.array([
                [0+4, 1+5, 2+6, 3+7],
                [8+12, 9+13, 10+14, 11+15]
            ])/2
            &gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=1)
            &gt;&gt;&gt; np.array([
                [0+1, 2+3],
                [4+5, 6+7],
                [8+9, 10+11],
                [12+13, 14+15]
            ])/2
            ```
        &#34;&#34;&#34;
        complementary = 1 if axis == 0 else 0
        s = mat.shape[complementary]
        q = mat.shape[axis]

        if s%factor != 0:
            raise ValueError(&#34;Error with matrix shape: {} is not a multiple of {}&#34;.format(s, factor))

        l = np.eye(int(q), dtype=float)
        r = np.repeat(np.eye(int(s/factor), dtype=float), repeats=factor, axis=axis)
        if axis:
            l, r = r, l
        
        return l.dot(mat).dot(r)/factor
    
    @staticmethod
    def _prime_factors(num: int) -&gt; list[int]:  
        primes = []
        # Using the while loop, we will print the number of two&#39;s that divide n  
        while num%2 == 0:  
            primes.append(2) 
            num = int(num*0.5)
    
        for i in range(3, int(np.sqrt(num)) + 1, 2):  
            # while i divides n , print i ad divide n  
            while num%i == 0:  
                primes.append(i)
                num = int(num/i)  
        
        if num &gt; 2:
            primes.append(num)

        return primes

    @staticmethod
    def _all_subsets(*el: object) -&gt; list:
        n = len(el)
        subsets = []
        for i in range(0, 2**n):
            bin_str = bin(i).replace(&#34;0b&#34;, &#34;&#34;).zfill(n)
            current = []
            for b, idx in zip(bin_str, range(0, len(bin_str))):
                b = int(b)
                if b:
                    current.append(el[idx])
            subsets.append(current)
        return subsets

    @staticmethod
    def _reduce_space(mat: np.ndarray, ideal_size: tuple[int]) -&gt; np.ndarray:
        &#34;&#34;&#34;
            Reduces a given matrix doing the mean method, by a factor close to the one given in argument. If no factor is given, the highest possible will be made
        &#34;&#34;&#34;
        for i, ideal, axis in zip(mat.shape, ideal_size, (1, 0)):
            primes = PostProcess._prime_factors(i)[0:16] # we take no more than 16 primes, otherwise the subsets will be too long to compute...
            subsets = PostProcess._all_subsets(*primes)
            all_factors = []
            for sub in subsets:
                nb = np.prod(sub)
                all_factors.append(nb)
            all_factors = np.array(all_factors)
            factor = all_factors[np.abs(i/all_factors - ideal).argmin()]
            mat = PostProcess.reduce_axis(mat, factor, axis=axis) if i &gt; ideal else mat

        return mat
    
    def _get_field(self, matrix_ideal_res: int) -&gt; tuple[np.ndarray]:
        self.fieldfile.seek(0, 0)
        Z = [] # mat[t,x]
        t = -1
        for f in self.fieldfile:
            if t &gt;= 0:
                Z.append(Simulation.str2list(f))
            t =+ 1
        Z = np.array(Z)

        ideal_size = (matrix_ideal_res, matrix_ideal_res) # Z matrix is often too large to be plot correctly...
        Z = PostProcess._reduce_space(Z, ideal_size) if matrix_ideal_res &lt; np.inf else Z
        tsize, xsize = Z.shape

        xline = np.linspace(0.0, self.L, xsize)
        tline = np.linspace(0.0, self.duration*self.c, tsize)
        X, T = np.meshgrid(xline, tline)

        return X.T, T.T, Z.T

    def plot3d(self, ax=plt.axes(), show=True, matrix_ideal_res=128, cmap=&#34;viridis&#34;):
        &#34;&#34;&#34;
            Draws a graph of the values of the field as a function of time, as a 3D graph

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
            :param matrix_ideal_res: ideal resolution for the matrix to plot
            :param cmap: colormap of the graph
        &#34;&#34;&#34;

        fig = plt.figure()
        ax = plt.axes(projection=&#39;3d&#39;)
        ax.plot_surface(*self._get_field(matrix_ideal_res),
                rstride=1, cstride=1,
                cmap=cmap, edgecolor=&#39;none&#39;)
        ax.set_title(&#34;Graph evolution of the field (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;x [m]&#34;)
        ax.set_ylabel(&#34;ct [m]&#34;)
        ax.set_zlabel(&#34;u [m]&#34;)
        plt.show() if show else None
    
    def plot2d(self, ax=plt.axes(), show=True, matrix_ideal_res=np.inf, cmap=&#34;viridis&#34;):
        &#34;&#34;&#34;
            Draws a graph of the values of the field as a function of time, as a 2D colored graph

            :param ax: matplotlib.pyplot axe to draw the graph
            :param show: if `True`, will show the graph at the end of execution
            :param label: string for legend
            :param matrix_ideal_res: ideal resolution for the matrix to plot
            :param cmap: colormap of the graph
        &#34;&#34;&#34;
        im = ax.pcolormesh(*self._get_field(matrix_ideal_res),
                cmap=cmap,
                rasterized=True)
        ax.set_title(&#34;Color mesh of the field (simulation {})&#34;.format(self.date))
        ax.set_xlabel(&#34;x [m]&#34;)
        ax.set_ylabel(&#34;ct [m]&#34;)
        ax.colorbar(im, ax=ax)
        plt.show() if show else None

    def fourier(self, *windows, frameskip=1, spectrograph=True, path=os.path.dirname(os.path.abspath(__file__))) -&gt; list[str]:
        &#34;&#34;&#34;
            Computes the spatial FFT of the field, in each given window, for all times. 

            :param windows: list of tuples that represents the windows (dimensionless values) where to compute
            :param frameskip: ill compute 1 out of `frameskip` frames for the FFT
            :param spectrograph: if `True` will generate and save a spectrograph of the FFT for each window in path
            :param path: path where to save the FFT
        &#34;&#34;&#34;
        ts = int(datetime.datetime.now().timestamp())
        self.fieldfile.seek(0, 0)
        self.particlesfile.seek(0, 0)
        r = []
        transforms = dict()
        if len(windows) == 0: # if no window given, take the whole string
            windows = [(0.0, 1.0)]
        for w in windows:
            key = str(w)
            transforms[key] = {}
            a, b = int(w[0]*self.nx), int(w[1]*self.nx)
            transforms[key][&#34;window_cells&#34;] = (a, b)
            transforms[key][&#34;mat&#34;] = np.array([[0.0]*(b - a)])
            filename = &#34;{}_{}{}.txt&#34;.format(ts, PostProcess.FOURIER_PREFIX, key)
            filepath = os.path.join(path, filename)
            r.append(filepath)
            file = open(filepath, &#34;w&#34;)
            transforms[key][&#34;file&#34;] = file
            copyinfos = self.infos.copy()
            copyinfos[&#34;fourier&#34;] = dict(window_cells=(a, b))
            file.write(&#34;{}\n&#34;.format(json.dumps(copyinfos)))

        osf = OneSpaceField(np.array([[0.0]*self.nx]), memory=3)
        frames = 0
        t = -1

        print(&#34;processing FFT...&#34;) if self.log else None
        for line in self.fieldfile:
            print(&#34;{}/{}&#34;.format(t, self.duration/self.dt), end=&#34;\r&#34;) if self.log else None
            if t &gt;= 0: # the file has a one-line header (json format)
                field = Simulation.str2list(line)
                osf.update(field)
                for tm in transforms.values():
                    towrite = &#34;&#34;
                    if t%frameskip == 0:
                        a, b = tm[&#34;window_cells&#34;]
                        mat = tm[&#34;mat&#34;]
                        fft, tm[&#34;f&#34;] = osf.space_fft(-1, self.infos[&#34;dx&#34;], xwindow=(a, b))
                        tm[&#34;mat&#34;] = np.append(mat, [fft], axis=0)
                        towrite = Simulation.list2str(fft)
                    tm[&#34;file&#34;].write(&#34;{}\n&#34;.format(towrite))
                    frames = tm[&#34;mat&#34;].shape[0] - 1
            t += 1

        time = np.linspace(0.0, self.duration, frames)
        
        if spectrograph:
            print(&#34;creating spectrograph...&#34;) if self.log else None
            for key, tm in transforms.items(): # creating the spectrography
                tm[&#34;file&#34;].close()
                f = tm[&#34;f&#34;]
                mat = tm[&#34;mat&#34;]
                ff, tt = np.meshgrid(f, time)
                mat = np.delete(mat, 0, 0)
                plt.pcolormesh(tt, ff, np.abs(mat), shading=&#34;gouraud&#34;)
                plt.title(key)
                plt.xlabel(&#34;Time [s]&#34;)
                plt.ylabel(&#34;Space frequency [rad/m]&#34;)
                pathsave = os.path.join(path, &#34;{}-{}-{}.png&#34;.format(PostProcess.SPECTRO_PREFIX, key, ts))
                plt.savefig(pathsave, dpi=1024)
                plt.close()
                print(&#34;&#39;{}&#39; successfully created&#34;.format(pathsave))
        
        return r</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="quantumstring.process.PostProcess.ANIM_PREFIX"><code class="name">var <span class="ident">ANIM_PREFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.COLOR_BLACK"><code class="name">var <span class="ident">COLOR_BLACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.COLOR_BLUE"><code class="name">var <span class="ident">COLOR_BLUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.COLOR_GRAY"><code class="name">var <span class="ident">COLOR_GRAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.COLOR_GREEN"><code class="name">var <span class="ident">COLOR_GREEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.COLOR_RED"><code class="name">var <span class="ident">COLOR_RED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.COLOR_WHITE"><code class="name">var <span class="ident">COLOR_WHITE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.FOURIER_PREFIX"><code class="name">var <span class="ident">FOURIER_PREFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quantumstring.process.PostProcess.SPECTRO_PREFIX"><code class="name">var <span class="ident">SPECTRO_PREFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="quantumstring.process.PostProcess.file2matrix"><code class="name flex">
<span>def <span class="ident">file2matrix</span></span>(<span>file: TextIOWrapper, type=builtins.float) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Given a file generated using the <code>quantum-string</code> library, converts and returns the data as a 2D NumPy array</p>
<p>:param file: Python opened file
:param type: type of the numbers inside the file (<code>int</code>, <code>float</code>, <code>np.complex</code>&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def file2matrix(file: TextIOWrapper, type=float) -&gt; np.ndarray:
    &#34;&#34;&#34;
        Given a file generated using the `quantum-string` library, converts and returns the data as a 2D NumPy array

        :param file: Python opened file
        :param type: type of the numbers inside the file (`int`, `float`, `np.complex`...)
    &#34;&#34;&#34;
    file.seek(0, 0)
    r = []
    t = -1
    for field in file:
        if t &gt;= 0:
            try:
                line = Simulation.str2list(field, type=type) if field != &#34;\n&#34; else None
                r.append(line) 
            except:
                raise ValueError(&#34;File given has some errors or is not from a simulation! Please check the file.\n Problem at line {} with &#39;{}&#39;&#34;.format(t + 1, field))
        t += 1
    return np.array(r)</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.reduce_axis"><code class="name flex">
<span>def <span class="ident">reduce_axis</span></span>(<span>mat: np.ndarray, factor: int, axis=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a matrix (an×m) or (n×am), returns a matrix (n×m) where the cells are the means of the cells surroundings</p>
<pre><code>&gt;&gt;&gt; mat = np.array([
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11],
    [12, 13, 14, 15]
])
&gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=0)
&gt;&gt;&gt; np.array([
    [0+4, 1+5, 2+6, 3+7],
    [8+12, 9+13, 10+14, 11+15]
])/2
&gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=1)
&gt;&gt;&gt; np.array([
    [0+1, 2+3],
    [4+5, 6+7],
    [8+9, 10+11],
    [12+13, 14+15]
])/2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def reduce_axis(mat: np.ndarray, factor: int, axis=0):
    &#34;&#34;&#34;
        Given a matrix (an×m) or (n×am), returns a matrix (n×m) where the cells are the means of the cells surroundings

        ```
        &gt;&gt;&gt; mat = np.array([
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [12, 13, 14, 15]
        ])
        &gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=0)
        &gt;&gt;&gt; np.array([
            [0+4, 1+5, 2+6, 3+7],
            [8+12, 9+13, 10+14, 11+15]
        ])/2
        &gt;&gt;&gt; PostProcess.reduce_axis(mat, 2, axis=1)
        &gt;&gt;&gt; np.array([
            [0+1, 2+3],
            [4+5, 6+7],
            [8+9, 10+11],
            [12+13, 14+15]
        ])/2
        ```
    &#34;&#34;&#34;
    complementary = 1 if axis == 0 else 0
    s = mat.shape[complementary]
    q = mat.shape[axis]

    if s%factor != 0:
        raise ValueError(&#34;Error with matrix shape: {} is not a multiple of {}&#34;.format(s, factor))

    l = np.eye(int(q), dtype=float)
    r = np.repeat(np.eye(int(s/factor), dtype=float), repeats=factor, axis=axis)
    if axis:
        l, r = r, l
    
    return l.dot(mat).dot(r)/factor</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quantumstring.process.PostProcess.anim"><code class="name flex">
<span>def <span class="ident">anim</span></span>(<span>self, path: str, title=False, resolution=(720, 480), fps=60, frameskip=1, yscale=1.0, compress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a animation of the simulation, using <code>opencv</code></p>
<p>:param path: path where to write the video
:param title: a title for the video. if <code>False</code>, automatic name
:param fps: frame per seconds for the generated video
:param frameskip: will compute 1 out of <code>frameskip</code> frames for the generated video
:param yscale: vertical scaling for field
:param compress: if <code>True</code>, will try to compress the video using <code>ffmeg</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anim(self, path: str, title=False, resolution=(720, 480), fps=60, frameskip=1, yscale=1.0, compress=True):
    &#34;&#34;&#34;
        Creates a animation of the simulation, using `opencv`

        :param path: path where to write the video
        :param title: a title for the video. if `False`, automatic name
        :param fps: frame per seconds for the generated video
        :param frameskip: will compute 1 out of `frameskip` frames for the generated video
        :param yscale: vertical scaling for field
        :param compress: if `True`, will try to compress the video using `ffmeg`
    &#34;&#34;&#34;
    ts = int(datetime.datetime.now().timestamp())
    self.fieldfile.seek(0, 0)
    self.particlesfile.seek(0, 0)

    title = PostProcess.ANIM_PREFIX if type(title) == bool and not title else title
    videopath = os.path.join(path, &#34;{}-{}-UNCOMPRESSED.mp4&#34;.format(title, ts))
    videopath_compressed = os.path.join(path, &#34;{}-{}.mp4&#34;.format(title, ts))

    lx, ly = resolution[0], resolution[1]
    margin_ppx = 5
    length_ppx = lx - 2*margin_ppx
    anim_params = dict(
        lx=lx,
        ly=ly,
        ox=margin_ppx,
        oy=0.5*ly,
        endstring=margin_ppx + length_ppx,
        ppx_per_m=length_ppx,
        mass_rad=3
    )

    baseimg = np.zeros((resolution[1], resolution[0], 3), np.uint8)

    textinfos = &#34;L={:.2f}m ρ={:.2f}g/m T={:.2f}N c={:.2f}m/s\n{} ~ {}&#34;.format(
        self.L, 
        self.rho*1e3, 
        self.T, 
        np.sqrt(self.T/self.rho),
        self.left,
        self.right
        )
    
    fontpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), &#34;Roboto-Regular.ttf&#34;)
    font = ImageFont.truetype(fontpath, 16)
    img_pil = Image.fromarray(baseimg)
    draw = ImageDraw.Draw(img_pil)
    draw.multiline_text((2, 2), textinfos, font=font, fill=PostProcess.COLOR_GRAY)
    lineh = 12
    hcount = 0
    for p, count in zip(self.particles, range(0, len(self.particles))):
        textparticle = &#34;m={:.1f}g, ω={:.1f}rad/s&#34;.format(p[Particle.STR_MASS]*1e3, p[Particle.STR_PULSATION])
        c = tuple(p[Particle.STR_COLOR])
        draw.text((lx - 200, 2 + hcount), textparticle, font=font, fill=c)
        hcount += lineh
        if count &gt; 4:
            break
    baseimg = np.array(img_pil)

    video = cv2.VideoWriter(videopath, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;), fps, (lx, ly))

    print(&#34;Animation for {} simulation:&#34;.format(self.date)) if self.log else None
    t = -1
    for field, particles in zip(self.fieldfile, self.particlesfile):
        if t &gt;= 0: # the file has a one-line header (json format)
            print(&#34;{}/{} images processed&#34;.format(int(t/frameskip), int(self.nt/frameskip)), end=&#34;\r&#34;) if self.log else None
            field = Simulation.str2list(field, type=float)
            particles = Simulation.str2list(particles, type=int)
            if t%frameskip == 0:
                img = self._img_field(baseimg, field, particles, anim_params, t, yscale=yscale)
                video.write(img)
        t += 1
    
    video.release()
    cv2.destroyAllWindows()

    return_path = videopath
    if compress:
        try:
            video = ffmpeg.input(videopath)
            video = ffmpeg.output(video, videopath_compressed, vcodec=&#34;h264&#34;)
            ffmpeg.run(video)
            os.remove(videopath)
            return_path = videopath_compressed
        except:
            print(&#34;WARNING: could not compress the video due to &#39;ffmpeg&#39; error...&#34;) if self.log else None

    print(&#34;video created successfully!&#34;) if self.log else None
    return return_path</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.energy"><code class="name flex">
<span>def <span class="ident">energy</span></span>(<span>self, ax=&lt;AxesSubplot:&gt;, show=True, label='') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a graph of the total energy of the field in function of time.</p>
<p>:param ax: matplotlib.pyplot axe to draw the graph
:param show: if <code>True</code>, will show the graph at the end of execution
:param label: string for legend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def energy(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
    &#34;&#34;&#34;
        Draws a graph of the total energy of the field in function of time.

        :param ax: matplotlib.pyplot axe to draw the graph
        :param show: if `True`, will show the graph at the end of execution
        :param label: string for legend
    &#34;&#34;&#34;
    self.energyfile.seek(0, 0)
    nrj_tot = []

    t = -1
    for energyline in self.energyfile:
        if t &gt;= 0:
            e = Simulation.str2list(energyline)
            nrj_tot.append(np.sum(e)*self.dx)
        t += 1
    
    tline = np.linspace(0.0, self.duration, self.nt)

    ax = plt.axes()
    ax.plot(tline, nrj_tot, &#34;.&#34;, label=label)
    ax.set_title(&#34;Total energy of the string (simulation {})&#34;.format(self.date))
    ax.set_xlabel(&#34;t [s]&#34;)
    ax.set_ylabel(&#34;Energy [J]&#34;)
    ax.legend() if label != &#34;&#34; else None
    plt.show() if show else None</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.fourier"><code class="name flex">
<span>def <span class="ident">fourier</span></span>(<span>self, *windows, frameskip=1, spectrograph=True, path='C:\\Users\\grdle\\Documents\\GitHub\\quantum-string\\quantumstring') ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the spatial FFT of the field, in each given window, for all times. </p>
<p>:param windows: list of tuples that represents the windows (dimensionless values) where to compute
:param frameskip: ill compute 1 out of <code>frameskip</code> frames for the FFT
:param spectrograph: if <code>True</code> will generate and save a spectrograph of the FFT for each window in path
:param path: path where to save the FFT</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fourier(self, *windows, frameskip=1, spectrograph=True, path=os.path.dirname(os.path.abspath(__file__))) -&gt; list[str]:
    &#34;&#34;&#34;
        Computes the spatial FFT of the field, in each given window, for all times. 

        :param windows: list of tuples that represents the windows (dimensionless values) where to compute
        :param frameskip: ill compute 1 out of `frameskip` frames for the FFT
        :param spectrograph: if `True` will generate and save a spectrograph of the FFT for each window in path
        :param path: path where to save the FFT
    &#34;&#34;&#34;
    ts = int(datetime.datetime.now().timestamp())
    self.fieldfile.seek(0, 0)
    self.particlesfile.seek(0, 0)
    r = []
    transforms = dict()
    if len(windows) == 0: # if no window given, take the whole string
        windows = [(0.0, 1.0)]
    for w in windows:
        key = str(w)
        transforms[key] = {}
        a, b = int(w[0]*self.nx), int(w[1]*self.nx)
        transforms[key][&#34;window_cells&#34;] = (a, b)
        transforms[key][&#34;mat&#34;] = np.array([[0.0]*(b - a)])
        filename = &#34;{}_{}{}.txt&#34;.format(ts, PostProcess.FOURIER_PREFIX, key)
        filepath = os.path.join(path, filename)
        r.append(filepath)
        file = open(filepath, &#34;w&#34;)
        transforms[key][&#34;file&#34;] = file
        copyinfos = self.infos.copy()
        copyinfos[&#34;fourier&#34;] = dict(window_cells=(a, b))
        file.write(&#34;{}\n&#34;.format(json.dumps(copyinfos)))

    osf = OneSpaceField(np.array([[0.0]*self.nx]), memory=3)
    frames = 0
    t = -1

    print(&#34;processing FFT...&#34;) if self.log else None
    for line in self.fieldfile:
        print(&#34;{}/{}&#34;.format(t, self.duration/self.dt), end=&#34;\r&#34;) if self.log else None
        if t &gt;= 0: # the file has a one-line header (json format)
            field = Simulation.str2list(line)
            osf.update(field)
            for tm in transforms.values():
                towrite = &#34;&#34;
                if t%frameskip == 0:
                    a, b = tm[&#34;window_cells&#34;]
                    mat = tm[&#34;mat&#34;]
                    fft, tm[&#34;f&#34;] = osf.space_fft(-1, self.infos[&#34;dx&#34;], xwindow=(a, b))
                    tm[&#34;mat&#34;] = np.append(mat, [fft], axis=0)
                    towrite = Simulation.list2str(fft)
                tm[&#34;file&#34;].write(&#34;{}\n&#34;.format(towrite))
                frames = tm[&#34;mat&#34;].shape[0] - 1
        t += 1

    time = np.linspace(0.0, self.duration, frames)
    
    if spectrograph:
        print(&#34;creating spectrograph...&#34;) if self.log else None
        for key, tm in transforms.items(): # creating the spectrography
            tm[&#34;file&#34;].close()
            f = tm[&#34;f&#34;]
            mat = tm[&#34;mat&#34;]
            ff, tt = np.meshgrid(f, time)
            mat = np.delete(mat, 0, 0)
            plt.pcolormesh(tt, ff, np.abs(mat), shading=&#34;gouraud&#34;)
            plt.title(key)
            plt.xlabel(&#34;Time [s]&#34;)
            plt.ylabel(&#34;Space frequency [rad/m]&#34;)
            pathsave = os.path.join(path, &#34;{}-{}-{}.png&#34;.format(PostProcess.SPECTRO_PREFIX, key, ts))
            plt.savefig(pathsave, dpi=1024)
            plt.close()
            print(&#34;&#39;{}&#39; successfully created&#34;.format(pathsave))
    
    return r</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.phasegraph_particles"><code class="name flex">
<span>def <span class="ident">phasegraph_particles</span></span>(<span>self, ax=&lt;AxesSubplot:&gt;, show=True, label='') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a graph of the derivative of the vertical position of the field, versus the actual vertical position of the field.</p>
<p>:param ax: matplotlib.pyplot axe to draw the graph
:param show: if <code>True</code>, will show the graph at the end of execution
:param label: string for legend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phasegraph_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
    &#34;&#34;&#34;
        Plots a graph of the derivative of the vertical position of the field, versus the actual vertical position of the field.

        :param ax: matplotlib.pyplot axe to draw the graph
        :param show: if `True`, will show the graph at the end of execution
        :param label: string for legend
    &#34;&#34;&#34;
    pp = self._particles_pos()
    for pos, part in zip(pp.T, self.particles):
        dpos = np.gradient(pos, self.dt)
        c = np.flip(np.array(part[Particle.STR_COLOR])/255.0)
        ax.plot(pos, dpos, marker=&#34;.&#34;, color=tuple(c))
        ax.legend([label])
    ax.set_title(&#34;Particles phase graph (simulation {})&#34;.format(self.date))
    ax.set_xlabel(&#34;$z$ [m]&#34;)
    ax.set_ylabel(&#34;$\\frac{\partial z}{\partial t}$ [m/s]&#34;)
    plt.show() if show else None</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.plot2d"><code class="name flex">
<span>def <span class="ident">plot2d</span></span>(<span>self, ax=&lt;AxesSubplot:&gt;, show=True, matrix_ideal_res=inf, cmap='viridis')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a graph of the values of the field as a function of time, as a 2D colored graph</p>
<p>:param ax: matplotlib.pyplot axe to draw the graph
:param show: if <code>True</code>, will show the graph at the end of execution
:param label: string for legend
:param matrix_ideal_res: ideal resolution for the matrix to plot
:param cmap: colormap of the graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot2d(self, ax=plt.axes(), show=True, matrix_ideal_res=np.inf, cmap=&#34;viridis&#34;):
    &#34;&#34;&#34;
        Draws a graph of the values of the field as a function of time, as a 2D colored graph

        :param ax: matplotlib.pyplot axe to draw the graph
        :param show: if `True`, will show the graph at the end of execution
        :param label: string for legend
        :param matrix_ideal_res: ideal resolution for the matrix to plot
        :param cmap: colormap of the graph
    &#34;&#34;&#34;
    im = ax.pcolormesh(*self._get_field(matrix_ideal_res),
            cmap=cmap,
            rasterized=True)
    ax.set_title(&#34;Color mesh of the field (simulation {})&#34;.format(self.date))
    ax.set_xlabel(&#34;x [m]&#34;)
    ax.set_ylabel(&#34;ct [m]&#34;)
    ax.colorbar(im, ax=ax)
    plt.show() if show else None</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.plot3d"><code class="name flex">
<span>def <span class="ident">plot3d</span></span>(<span>self, ax=&lt;AxesSubplot:&gt;, show=True, matrix_ideal_res=128, cmap='viridis')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a graph of the values of the field as a function of time, as a 3D graph</p>
<p>:param ax: matplotlib.pyplot axe to draw the graph
:param show: if <code>True</code>, will show the graph at the end of execution
:param label: string for legend
:param matrix_ideal_res: ideal resolution for the matrix to plot
:param cmap: colormap of the graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot3d(self, ax=plt.axes(), show=True, matrix_ideal_res=128, cmap=&#34;viridis&#34;):
    &#34;&#34;&#34;
        Draws a graph of the values of the field as a function of time, as a 3D graph

        :param ax: matplotlib.pyplot axe to draw the graph
        :param show: if `True`, will show the graph at the end of execution
        :param label: string for legend
        :param matrix_ideal_res: ideal resolution for the matrix to plot
        :param cmap: colormap of the graph
    &#34;&#34;&#34;

    fig = plt.figure()
    ax = plt.axes(projection=&#39;3d&#39;)
    ax.plot_surface(*self._get_field(matrix_ideal_res),
            rstride=1, cstride=1,
            cmap=cmap, edgecolor=&#39;none&#39;)
    ax.set_title(&#34;Graph evolution of the field (simulation {})&#34;.format(self.date))
    ax.set_xlabel(&#34;x [m]&#34;)
    ax.set_ylabel(&#34;ct [m]&#34;)
    ax.set_zlabel(&#34;u [m]&#34;)
    plt.show() if show else None</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.plot_cells"><code class="name flex">
<span>def <span class="ident">plot_cells</span></span>(<span>self, *cells: int, ax=&lt;AxesSubplot:&gt;, show=True) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a graph of the value of the cells given, in function of time</p>
<p>:param cells: cells to draw the value
:param ax: matplotlib.pyplot axe to draw the graph
:param show: if <code>True</code>, will show the graph at the end of execution
:param label: string for legend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cells(self, *cells: int, ax=plt.axes(), show=True) -&gt; np.ndarray:
    &#34;&#34;&#34;
        Draws a graph of the value of the cells given, in function of time

        :param cells: cells to draw the value
        :param ax: matplotlib.pyplot axe to draw the graph
        :param show: if `True`, will show the graph at the end of execution
        :param label: string for legend
    &#34;&#34;&#34;
    cells_vals = self._get_cells(*cells)
    ax.set_title(&#34;Cells plotting (simulation {})&#34;.format(self.date))
    ax.set_xlabel(&#34;t [s]&#34;)
    ax.set_ylabel(&#34;u [m]&#34;)

    tline = np.linspace(0.0, self.duration, self.nt)
    for c, idx in zip(cells_vals.T, cells):
        ax.plot(tline, c, label=&#34;x={}m&#34;.format(idx*self.dx))
        ax.legend()
    
    plt.plot() if show else None</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.plot_grad_particles"><code class="name flex">
<span>def <span class="ident">plot_grad_particles</span></span>(<span>self, ax=&lt;AxesSubplot:&gt;, show=True, label='') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a graph of the gradient near the particle.
Solid line for the left gradient, dashed line for right gradient.</p>
<p>:param ax: matplotlib.pyplot axe to draw the graph
:param show: if <code>True</code>, will show the graph at the end of execution
:param label: string for legend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_grad_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
    &#34;&#34;&#34;
        Draws a graph of the gradient near the particle. 
        Solid line for the left gradient, dashed line for right gradient.

        :param ax: matplotlib.pyplot axe to draw the graph
        :param show: if `True`, will show the graph at the end of execution
        :param label: string for legend
    &#34;&#34;&#34;

    ax.set_title(&#34;Gradient at left (solid) and right (dashed) to the particles&#34;)
    ax.set_xlabel(&#34;$t [s]$&#34;)
    ax.set_ylabel(&#34;$\frac{\partial u}{\partial x}$&#34;)

    tline = np.linspace(0.0, self.duration, self.nt)
    for part in self.particles:
        cell = part[Particle.STR_INIT_POS]
        color = part[Particle.STR_COLOR]
        l, r = cell - 1, cell + 1
        vpart = self._get_cells(l, cell, r)

        grad_left = (vpart[:,1] - vpart[:,0])/self.dx
        grad_right = (vpart[:,2] - vpart[:,1])/self.dx

        ax.plot(tline, grad_left, linestyle=&#34;solid&#34;, color=color)
        ax.plot(tline, grad_right, linestyle=&#34;dashed&#34;, color=color)
    
    plt.show() if show else None</code></pre>
</details>
</dd>
<dt id="quantumstring.process.PostProcess.plot_particles"><code class="name flex">
<span>def <span class="ident">plot_particles</span></span>(<span>self, ax=&lt;AxesSubplot:&gt;, show=True, label='') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a graph of the vertical position of the field where the particles are versus the time.</p>
<p>:param ax: matplotlib.pyplot axe to draw the graph
:param show: if <code>True</code>, will show the graph at the end of execution
:param label: string for legend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_particles(self, ax=plt.axes(), show=True, label=&#34;&#34;) -&gt; None:
    &#34;&#34;&#34;
        Plots a graph of the vertical position of the field where the particles are versus the time.

        :param ax: matplotlib.pyplot axe to draw the graph
        :param show: if `True`, will show the graph at the end of execution
        :param label: string for legend
    &#34;&#34;&#34;
    pp = self._particles_pos()
    tline = np.linspace(0, self.duration, self.nt)
    for pos, part in zip(pp.T, self.particles):
        c = np.flip(np.array(part[Particle.STR_COLOR])/255.0)
        ax.plot(tline, pos, color=tuple(c))
        ax.legend([label]) if label != &#34;&#34; else None
    ax.set_title(&#34;Particles vertical position (simulation {})&#34;.format(self.date))
    ax.set_xlabel(&#34;t [s]&#34;)
    ax.set_ylabel(&#34;z [m]&#34;)
    plt.show() if show else None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="quantumstring" href="index.html">quantumstring</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="quantumstring.process.PostProcess" href="#quantumstring.process.PostProcess">PostProcess</a></code></h4>
<ul class="">
<li><code><a title="quantumstring.process.PostProcess.ANIM_PREFIX" href="#quantumstring.process.PostProcess.ANIM_PREFIX">ANIM_PREFIX</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.COLOR_BLACK" href="#quantumstring.process.PostProcess.COLOR_BLACK">COLOR_BLACK</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.COLOR_BLUE" href="#quantumstring.process.PostProcess.COLOR_BLUE">COLOR_BLUE</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.COLOR_GRAY" href="#quantumstring.process.PostProcess.COLOR_GRAY">COLOR_GRAY</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.COLOR_GREEN" href="#quantumstring.process.PostProcess.COLOR_GREEN">COLOR_GREEN</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.COLOR_RED" href="#quantumstring.process.PostProcess.COLOR_RED">COLOR_RED</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.COLOR_WHITE" href="#quantumstring.process.PostProcess.COLOR_WHITE">COLOR_WHITE</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.FOURIER_PREFIX" href="#quantumstring.process.PostProcess.FOURIER_PREFIX">FOURIER_PREFIX</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.SPECTRO_PREFIX" href="#quantumstring.process.PostProcess.SPECTRO_PREFIX">SPECTRO_PREFIX</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.anim" href="#quantumstring.process.PostProcess.anim">anim</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.energy" href="#quantumstring.process.PostProcess.energy">energy</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.file2matrix" href="#quantumstring.process.PostProcess.file2matrix">file2matrix</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.fourier" href="#quantumstring.process.PostProcess.fourier">fourier</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.phasegraph_particles" href="#quantumstring.process.PostProcess.phasegraph_particles">phasegraph_particles</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.plot2d" href="#quantumstring.process.PostProcess.plot2d">plot2d</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.plot3d" href="#quantumstring.process.PostProcess.plot3d">plot3d</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.plot_cells" href="#quantumstring.process.PostProcess.plot_cells">plot_cells</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.plot_grad_particles" href="#quantumstring.process.PostProcess.plot_grad_particles">plot_grad_particles</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.plot_particles" href="#quantumstring.process.PostProcess.plot_particles">plot_particles</a></code></li>
<li><code><a title="quantumstring.process.PostProcess.reduce_axis" href="#quantumstring.process.PostProcess.reduce_axis">reduce_axis</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>